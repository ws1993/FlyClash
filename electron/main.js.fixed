const { app, BrowserWindow, Tray, Menu, ipcMain, dialog, shell, nativeTheme, nativeImage } = require('electron');
const path = require('path');
const fs = require('fs');
const { spawn, execSync } = require('child_process');
const isDev = process.env.NODE_ENV === 'development';
const yaml = require('js-yaml');
const WebSocket = require('ws');
const net = require('net');
const http = require('http');
const serveStatic = require('serve-static');
const finalhandler = require('finalhandler');

// åº”ç”¨ç‰ˆæœ¬å?- ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ç•Œé¢æ˜¾ç¤ºçš„ç‰ˆæœ¬
const APP_VERSION = '0.1.1';

let mainWindow;
let tray;
let mihomoProcess;
let configFilePath;
let isQuitting = false;
let autoStartEnabled = true; // é»˜è®¤å¯ç”¨è‡ªåŠ¨å¯åŠ¨
let currentNode = null;

// è¿æ¥ç®¡ç†ç›¸å…³å˜é‡
let connectionsWebSocket = null;
let connectionsRetry = 10;
let lastConnectionsInfo = {
  downloadTotal: 0,
  uploadTotal: 0,
  connections: [],
  memory: 0,
  currentNode: null,
  activeConnections: 0
};

// ä¿®æ”¹åº”ç”¨çš„appNameï¼Œç¡®ä¿ä¿å­˜åœ¨Roamingç›®å½•ä¸‹çš„æ–‡ä»¶å¤¹åä¸ºflyclash
app.name = 'flyclash';

// åº”ç”¨æ•°æ®å­˜å‚¨è·¯å¾„
const userDataPath = app.getPath('userData');
const configDir = path.join(userDataPath, 'config');

// æ·»åŠ å‡½æ•°ç”¨äºæŸ¥æ‰¾mihomoå¯æ‰§è¡Œæ–‡ä»?function findMihomoExecutable() {
  let binPath = null;
  
  if (isDev) {
    // å¼€å‘ç¯å¢ƒä¸‹ï¼Œå°è¯•æŸ¥æ‰¾é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„æ‰€æœ‰å¯èƒ½çš„mihomoå†…æ ¸æ–‡ä»¶
    const devDirPath = process.cwd();
    const parentDir = path.join(devDirPath, '..');
    
    try {
      // æœç´¢çˆ¶ç›®å½•ä¸­æ‰€æœ‰çš„exeæ–‡ä»¶
      const files = fs.readdirSync(parentDir);
      const mihomoExeFiles = files.filter(file => 
        file.toLowerCase().includes('mihomo') && 
        file.endsWith('.exe')
      );
      
      if (mihomoExeFiles.length > 0) {
        // ä½¿ç”¨æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªmihomo exeæ–‡ä»¶
        binPath = path.join(parentDir, mihomoExeFiles[0]);
        console.log('å¼€å‘ç¯å¢ƒæ‰¾åˆ°mihomoå†…æ ¸:', binPath);
      }
    } catch (error) {
      console.error('æœç´¢å¼€å‘ç¯å¢ƒå†…æ ¸æ–‡ä»¶å¤±è´?', error);
    }
    
    // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•ä½¿ç”¨é»˜è®¤è·¯å¾„
    if (!binPath) {
      binPath = path.join(parentDir, 'mihomo-windows-amd64.exe');
    }
  } else {
    // ç”Ÿäº§ç¯å¢ƒï¼Œæœç´¢resources/coresç›®å½•
    const coresDir = path.join(process.resourcesPath, 'cores');
    
    try {
      if (fs.existsSync(coresDir)) {
        // æœç´¢coresç›®å½•ä¸­æ‰€æœ‰çš„exeæ–‡ä»¶
        const files = fs.readdirSync(coresDir);
        const exeFiles = files.filter(file => file.endsWith('.exe'));
        
        if (exeFiles.length > 0) {
          // ä¼˜å…ˆä½¿ç”¨åŒ…å«mihomoçš„æ–‡ä»¶å
          const mihomoExe = exeFiles.find(file => file.toLowerCase().includes('mihomo'));
          
          if (mihomoExe) {
            binPath = path.join(coresDir, mihomoExe);
            console.log('å‘ç°mihomoå†…æ ¸:', binPath);
          } else {
            // å¦‚æœæ²¡æœ‰mihomoåç§°çš„exeï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªexeæ–‡ä»¶
            binPath = path.join(coresDir, exeFiles[0]);
            console.log('ä½¿ç”¨é»˜è®¤å†…æ ¸æ–‡ä»¶:', binPath);
          }
        }
      }
    } catch (error) {
      console.error('æœç´¢å†…æ ¸æ–‡ä»¶å¤±è´¥:', error);
    }
    
    // å¦‚æœä»ç„¶æ²¡æ‰¾åˆ°ï¼Œå°è¯•ä½¿ç”¨é»˜è®¤è·¯å¾„
    if (!binPath) {
      binPath = path.join(process.resourcesPath, 'cores/mihomo-windows-amd64.exe');
    }
  }
  
  return binPath;
}

// ç¡®ä¿é…ç½®ç›®å½•å­˜åœ¨
if (!fs.existsSync(configDir)) {
  fs.mkdirSync(configDir, { recursive: true });
}

// ç”¨æˆ·è®¾ç½®é…ç½®æ–‡ä»¶è·¯å¾„
const userSettingsPath = path.join(userDataPath, 'user-settings.yaml');

// ç¡®ä¿ç”¨æˆ·è®¾ç½®æ–‡ä»¶å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»?function ensureUserSettingsFile() {
  if (!fs.existsSync(userSettingsPath)) {
    // é»˜è®¤è®¾ç½®
    const defaultSettings = {
      'mixed-port': 7890,
      'allow-lan': false,
      'ipv6': false
    };
    
    try {
      fs.writeFileSync(userSettingsPath, yaml.dump(defaultSettings), 'utf8');
      console.log('å·²åˆ›å»ºç”¨æˆ·è®¾ç½®æ–‡ä»?', userSettingsPath);
    } catch (error) {
      console.error('åˆ›å»ºç”¨æˆ·è®¾ç½®æ–‡ä»¶å¤±è´¥:', error);
    }
  }
}

// è¯»å–ç”¨æˆ·è®¾ç½®
function getUserSettings() {
  try {
    ensureUserSettingsFile();
    const content = fs.readFileSync(userSettingsPath, 'utf8');
    return yaml.load(content) || {};
  } catch (error) {
    console.error('è¯»å–ç”¨æˆ·è®¾ç½®å¤±è´¥:', error);
    return {};
  }
}

// æ›´æ–°ç”¨æˆ·è®¾ç½®
function updateUserSettings(settings) {
  try {
    ensureUserSettingsFile();
    const currentSettings = getUserSettings();
    
    // éªŒè¯æ–°è®¾ç½?    if ('mixed-port' in settings) {
      if (typeof settings['mixed-port'] !== 'number' || 
          settings['mixed-port'] < 1 || settings['mixed-port'] > 65535) {
        console.warn('ç«¯å£å·æ— æ•ˆï¼Œå°†ä½¿ç”¨é»˜è®¤å€?);
        settings['mixed-port'] = 7890;
      }
    }
    
    // è½¬æ¢å¸ƒå°”å‹å­—æ®?    for (const key of ['allow-lan', 'ipv6']) {
      if (key in settings) {
        settings[key] = Boolean(settings[key]);
      }
    }
    
    const newSettings = { ...currentSettings, ...settings };
    fs.writeFileSync(userSettingsPath, yaml.dump(newSettings), 'utf8');
    console.log('å·²æ›´æ–°ç”¨æˆ·è®¾ç½?', newSettings);
    
    // å¦‚æœmihomoæ­£åœ¨è¿è¡Œï¼Œé‡æ–°ç”Ÿæˆå¹¶é‡è½½é…ç½®
    if (mihomoProcess && mihomoProcess.pid && configFilePath) {
      // é‡æ–°ç”Ÿæˆåˆå¹¶é…ç½®å¹¶çƒ­é‡è½½
      regenerateAndReloadConfig();
    }
    
    return true;
  } catch (error) {
    console.error('æ›´æ–°ç”¨æˆ·è®¾ç½®å¤±è´¥:', error);
    return false;
  }
}

// æµé‡ç»Ÿè®¡ç›¸å…³å˜é‡
let lastTrafficStats = {
  up: 0,
  down: 0,
  upSpeed: 0,
  downSpeed: 0,
  timestamp: Date.now()
};

// WebSocketè¿æ¥
let trafficWebSocket = null;
let trafficRetry = 10;
let lastValidStats = null;  // ç”¨äºå­˜å‚¨æœ€åä¸€æ¬¡æœ‰æ•ˆçš„æµé‡æ•°æ®

// æ ¼å¼åŒ–æµé‡æ•°æ?function formatTraffic(bytes) {
  if (bytes === 0) return '0 B';
  
  const units = ['B', 'KB', 'MB', 'GB', 'TB'];
  let i = 0;
  let size = bytes;
  
  while (size >= 1024 && i < units.length - 1) {
    size /= 1024;
    i++;
  }
  
  return `${size.toFixed(2)} ${units[i]}`;
}

// æ ¼å¼åŒ–é€Ÿåº¦
function formatSpeed(bytesPerSecond) {
  if (bytesPerSecond === 0) return '0 B/s';
  
  const units = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
  let i = 0;
  let speed = bytesPerSecond;
  
  while (speed >= 1024 && i < units.length - 1) {
    speed /= 1024;
    i++;
  }
  
  return `${speed.toFixed(2)} ${units[i]}`;
}

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1000,
    height: 700,
    minWidth: 800,
    minHeight: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
    show: false,
    frame: true,
    titleBarStyle: 'hidden',
    titleBarOverlay: {
      color: nativeTheme.shouldUseDarkColors ? '#1a1a1a' : '#f9f9f9',
      symbolColor: nativeTheme.shouldUseDarkColors ? '#f3f4f6' : '#000000',
      height: 48
    },
    backgroundColor: nativeTheme.shouldUseDarkColors ? '#1f2937' : '#ffffff'
  });

  // ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–
  nativeTheme.on('updated', () => {
    mainWindow.setTitleBarOverlay({
      color: nativeTheme.shouldUseDarkColors ? '#1a1a1a' : '#f9f9f9',
      symbolColor: nativeTheme.shouldUseDarkColors ? '#f3f4f6' : '#000000',
      height: 48
    });
  });

  // å¼€å‘ç¯å¢ƒä½¿ç”¨localhost:3000
  if (isDev) {
    const startUrl = 'http://localhost:3000';
  mainWindow.loadURL(startUrl);
  } else {
    // ç”Ÿäº§ç¯å¢ƒä½¿ç”¨å†…éƒ¨HTTPæœåŠ¡å™¨æä¾›é¡µé?    loadPageWithServer('');
  }

  // ç¡®ä¿CSSåŠ è½½æ­£ç¡®
  mainWindow.webContents.on('did-finish-load', () => {
    if (!isDev) {
      try {
        // å°è¯•æ³¨å…¥æ­£ç¡®çš„CSSè·¯å¾„
        const cssDir = path.join(__dirname, '../out/_next/static/css');
        const cssFiles = fs.readdirSync(cssDir);
        if (cssFiles.length > 0) {
          const cssContent = fs.readFileSync(path.join(cssDir, cssFiles[0]), 'utf8');
          mainWindow.webContents.insertCSS(cssContent)
            .catch(err => console.error('æ³¨å…¥CSSå†…å®¹å¤±è´¥:', err));
        } else {
          console.error('æ²¡æœ‰æ‰¾åˆ°CSSæ–‡ä»¶');
        }
      } catch (error) {
        console.error('CSSæ³¨å…¥è¿‡ç¨‹ä¸­å‡ºé”?', error);
      }
    }
  });

  // å¤„ç†å¯¼èˆªè¯·æ±‚
  ipcMain.handle('loadPage', async (event, pageName) => {
    try {
      console.log(`åˆ‡æ¢åˆ°é¡µé? ${pageName}`);
      
      // åœ¨å¼€å‘æ¨¡å¼ä¸‹ä½¿ç”¨localhost:3000
      if (isDev) {
        await mainWindow.loadURL(`http://localhost:3000/${pageName}`);
        return { success: true };
      }

      // ç”Ÿäº§æ¨¡å¼ - ä½¿ç”¨å…±äº«çš„HTTPæœåŠ¡å™¨å‡½æ•?      await loadPageWithServer(pageName);
      
      return { success: true };
    } catch (error) {
      console.error('åŠ è½½é¡µé¢å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  if (isDev) {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
    
    // é€šçŸ¥æ¸²æŸ“è¿›ç¨‹å½“å‰ä¸»é¢˜çŠ¶æ€?    try {
      const currentTheme = nativeTheme.themeSource === 'system' 
        ? (nativeTheme.shouldUseDarkColors ? 'dark' : 'light')
        : nativeTheme.themeSource;
      mainWindow.webContents.send('theme-changed', currentTheme);
      console.log('å·²é€šçŸ¥æ¸²æŸ“è¿›ç¨‹å½“å‰ä¸»é¢˜:', currentTheme);
    } catch (error) {
      console.error('é€šçŸ¥ä¸»é¢˜çŠ¶æ€å¤±è´?', error);
    }
    
    // è‡ªåŠ¨å¯åŠ¨Mihomo
    if (autoStartEnabled) {
      setTimeout(autoStartMihomo, 1000);
    }
  });

  mainWindow.on('close', (event) => {
    if (!isQuitting) {
      event.preventDefault();
      mainWindow.hide();
    }
  });
}

async function startMihomo(configPath) {
  if (mihomoProcess) {
    mihomoProcess.kill();
  }

  configFilePath = configPath;
  
  // ä½¿ç”¨å…¨å±€è¾…åŠ©å‡½æ•°æŸ¥æ‰¾mihomoå†…æ ¸
  const binPath = findMihomoExecutable();

  if (!fs.existsSync(binPath)) {
    console.error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„å†…æ ¸æ–‡ä»¶:', binPath);
    dialog.showErrorBox('é”™è¯¯', 'æ— æ³•æ‰¾åˆ°æœ‰æ•ˆçš„å†…æ ¸æ–‡ä»¶ï¼Œè¯·ç¡®ä¿åº”ç”¨å®‰è£…æ­£ç¡?);
    return false;
  }
  
  console.log('ä½¿ç”¨å†…æ ¸æ–‡ä»¶:', binPath);

  try {
    // ç¡®ä¿é…ç½®æ–‡ä»¶å­˜åœ¨
    if (!fs.existsSync(configPath)) {
      dialog.showErrorBox('é”™è¯¯', `é…ç½®æ–‡ä»¶ä¸å­˜åœ? ${configPath}`);
      return false;
    }

    // åˆ›å»ºmihomoå·¥ä½œç›®å½•
    const mihomoDir = path.join(userDataPath, 'mihomo');
    if (!fs.existsSync(mihomoDir)) {
      fs.mkdirSync(mihomoDir, { recursive: true });
    }
    
    // ç¡®è®¤å·¥ä½œç›®å½•æœ‰å†™æƒé™
    try {
      const testFile = path.join(mihomoDir, 'test_write_permission.txt');
      fs.writeFileSync(testFile, 'test');
      fs.unlinkSync(testFile);
      console.log('å·¥ä½œç›®å½•å†™æƒé™æ­£å¸?);
    } catch (error) {
      console.error('å·¥ä½œç›®å½•å†™æƒé™ä¸è¶?', error);
      dialog.showErrorBox('æƒé™é”™è¯¯', `Mihomoå·¥ä½œç›®å½•æ²¡æœ‰å†™æƒé™? ${error.message}`);
      return false;
    }

    // è¯»å–ç”¨æˆ·è®¾ç½®
    const userSettings = getUserSettings();
    console.log('å·²è¯»å–ç”¨æˆ·è®¾ç½?', userSettings);

    // è¯»å–åŸå§‹é…ç½®
    const configFilename = path.basename(configPath);
    let configContent = fs.readFileSync(configPath, 'utf8');
    const config = yaml.load(configContent);

    // åˆ›å»ºé«˜ä¼˜å…ˆçº§é…ç½®æ–‡ä»¶ï¼ˆåˆå¹¶ç”¨æˆ·è®¾ç½®å’ŒåŸå§‹é…ç½®ï¼?    const overrideConfigFilename = 'override-' + configFilename;
    const overrideConfigPath = path.join(mihomoDir, overrideConfigFilename);
    
    // ä½¿ç”¨æ·±åº¦åˆå¹¶æ›¿æ¢åŸæ¥çš„æµ…åˆå¹¶
    let mergedConfig, mergedConfigContent;
    
    try {
      // æ™ºèƒ½åˆå¹¶é…ç½®ï¼ˆç”¨æˆ·è®¾ç½®ä¼˜å…ˆçº§æ›´é«˜ï¼?      mergedConfig = deepMergeConfig(config, userSettings);
      // éªŒè¯åˆå¹¶åçš„é…ç½®
      mergedConfig = validateMergedConfig(mergedConfig);
      mergedConfigContent = yaml.dump(mergedConfig);
    } catch (error) {
      console.error('é…ç½®åˆå¹¶å¤±è´¥:', error);
      
      // ä½¿ç”¨å®‰å…¨çš„å›é€€é…ç½®
      const safeConfig = {
        ...config,
        'mixed-port': userSettings['mixed-port'] || 7890,
        'allow-lan': !!userSettings['allow-lan'],
        'ipv6': !!userSettings['ipv6'],
        'log-level': userSettings['log-level'] || 'info'
      };
      
      mergedConfig = safeConfig;
      mergedConfigContent = yaml.dump(safeConfig);
      console.log('ä½¿ç”¨å®‰å…¨çš„å›é€€é…ç½®');
    }
    
    // ä¿å­˜åˆå¹¶åçš„é…ç½®
    fs.writeFileSync(overrideConfigPath, mergedConfigContent, 'utf8');
    console.log(`å·²åˆ›å»ºé«˜ä¼˜å…ˆçº§é…ç½®æ–‡ä»? ${overrideConfigPath}`);

    // è®°å½•å¯åŠ¨ä¿¡æ¯
    console.log(`å¯åŠ¨Mihomo: ${binPath} -f ${overrideConfigPath}`);
    console.log(`å·¥ä½œç›®å½•: ${mihomoDir}`);

    // éªŒè¯é…ç½®æ–‡ä»¶å†…å®¹
    try {
      // è¿™äº›æ£€æŸ¥å·²ç»åœ¨validateMergedConfigä¸­å¤„ç†ï¼Œè¿™é‡Œæ˜¯é¢å¤–çš„å®‰å…¨æ£€æŸ?      if (!mergedConfig.proxies || !Array.isArray(mergedConfig.proxies)) {
        dialog.showErrorBox('é…ç½®é”™è¯¯', 'é…ç½®æ–‡ä»¶ç¼ºå°‘å¿…è¦çš„proxieså­—æ®µ');
        return false;
      }

      if (!mergedConfig['proxy-groups'] || !Array.isArray(mergedConfig['proxy-groups'])) {
        dialog.showErrorBox('é…ç½®é”™è¯¯', 'é…ç½®æ–‡ä»¶ç¼ºå°‘å¿…è¦çš„proxy-groupså­—æ®µ');
        return false;
      }

      // æ£€æŸ¥ä»£ç†ç»„æ˜¯å¦ä¸ºç©º
      if (mergedConfig['proxy-groups'].length === 0) {
        console.warn('è­¦å‘Š: é…ç½®æ–‡ä»¶ä¸­çš„ä»£ç†ç»„ä¸ºç©?);
        // ä¸è¿”å›falseï¼Œå…è®¸ç»§ç»­å°è¯•å¯åŠ?      }

      // æ£€æŸ¥ä»£ç†æ˜¯å¦ä¸ºç©?      if (mergedConfig.proxies.length === 0) {
        console.warn('è­¦å‘Š: é…ç½®æ–‡ä»¶ä¸­æ²¡æœ‰ä»£ç†èŠ‚ç‚?);
        // ä¸è¿”å›falseï¼Œå…è®¸ç»§ç»­å°è¯•å¯åŠ?      }
    } catch (error) {
      console.error('é…ç½®æ–‡ä»¶éªŒè¯å¤±è´¥:', error);
      dialog.showErrorBox('é…ç½®æ–‡ä»¶é”™è¯¯', `è§£æé…ç½®æ–‡ä»¶å¤±è´¥: ${error.message}`);
      return false;
    }

    // å¯åŠ¨mihomoï¼Œä½¿ç”¨é«˜ä¼˜å…ˆçº§çš„é…ç½®æ–‡ä»¶
    mihomoProcess = spawn(binPath, ['-f', overrideConfigPath], {
      cwd: mihomoDir,
      env: {
        ...process.env,
        MIHOMO_CORE_PATH: mihomoDir
      },
      windowsHide: false,
      stdio: ['ignore', 'pipe', 'pipe']
    });
    
    mihomoProcess.stdout.on('data', (data) => {
      const logContent = data.toString();
      console.log(`mihomo stdout: ${logContent}`);
      
      // æ£€æŸ¥æ˜¯å¦æœ‰é…ç½®ç›¸å…³æ—¥å¿—
      if (logContent.includes('Config') || logContent.includes('allow-lan')) {
        console.log('å‘ç°é…ç½®ç›¸å…³æ—¥å¿—:', logContent);
      }
      
      if (mainWindow) {
        mainWindow.webContents.send('mihomo-log', logContent);
      }
      
      // ç›´æ¥è¾“å‡ºåˆ°æ§åˆ¶å°/ç»ˆç«¯
      process.stdout.write(data);
    });

    mihomoProcess.stderr.on('data', (data) => {
      console.error(`mihomo stderr: ${data}`);
      if (mainWindow) {
        mainWindow.webContents.send('mihomo-error', data.toString());
      }
      
      // ç›´æ¥è¾“å‡ºåˆ°æ§åˆ¶å°/ç»ˆç«¯
      process.stderr.write(data);
    });

    mihomoProcess.on('close', (code) => {
      console.log(`mihomo process exited with code ${code}`);
      // ä½¿ç”¨é›†ä¸­å¤„ç†å‡½æ•°å¤„ç†mihomoè¿›ç¨‹é€€å‡?      handleMihomoProcessExit(code);
    });

    // æ£€æŸ¥è¿›ç¨‹æ˜¯å¦æˆåŠŸå¯åŠ?    await new Promise(resolve => setTimeout(resolve, 1000));
    if (mihomoProcess && mihomoProcess.exitCode !== null) {
      console.error(`Mihomoç«‹å³é€€å‡ºï¼Œé€€å‡ºä»£ç ? ${mihomoProcess.exitCode}`);
      dialog.showErrorBox('å¯åŠ¨å¤±è´¥', `Mihomoå¯åŠ¨åç«‹å³é€€å‡ºï¼Œé€€å‡ºä»£ç ? ${mihomoProcess.exitCode}`);
      return false;
    }

    // å¯åŠ¨æˆåŠŸåä¿å­˜è¿™ä¸ªé…ç½®æ–‡ä»¶ä½œä¸ºæœ€åä½¿ç”¨çš„é…ç½®
    try {
      const lastConfigPath = path.join(userDataPath, 'last-config.json');
      fs.writeFileSync(lastConfigPath, JSON.stringify({ path: configPath }, null, 2), 'utf8');
      console.log('å·²å°†æ­¤é…ç½®è®¾ä¸ºæœ€åä½¿ç”¨çš„é…ç½®:', configPath);
    } catch (saveError) {
      console.error('ä¿å­˜æœ€åä½¿ç”¨çš„é…ç½®å¤±è´¥:', saveError);
      // ç»§ç»­æ‰§è¡Œï¼Œè¿™ä¸æ˜¯è‡´å‘½é”™è¯¯
    }
    
    if (mihomoProcess) {
      startTrafficStatsUpdate();
    }

    return true;
  } catch (error) {
    console.error('Failed to start mihomo:', error);
    dialog.showErrorBox('å¯åŠ¨å¤±è´¥', `æ— æ³•å¯åŠ¨Mihomo: ${error.message}`);
    return false;
  }
}

function setupTray() {
  // å°è¯•å¤šä¸ªå¯èƒ½çš„å›¾æ ‡è·¯å¾?  let iconPath = null;
  const possiblePaths = [
    // å¼€å‘ç¯å¢ƒè·¯å¾?    isDev ? path.join(__dirname, '../public/favicon.ico') : null,
    // ç”Ÿäº§ç¯å¢ƒé¦–é€‰è·¯å¾?    !isDev ? path.join(process.resourcesPath, 'public/favicon.ico') : null,
    // å¤‡é€‰è·¯å¾?- ç›´æ¥åœ?resources ä¸?    !isDev ? path.join(process.resourcesPath, 'favicon.ico') : null,
    // åº”ç”¨ç¨‹åºç›®å½•ä¸?    !isDev ? path.join(app.getAppPath(), 'public/favicon.ico') : null,
    // out ç›®å½•ä¸?    !isDev ? path.join(app.getAppPath(), 'out/favicon.ico') : null
  ].filter(Boolean); // è¿‡æ»¤æ?null å€?  
  // å°è¯•æ¯ä¸ªè·¯å¾„ï¼Œç›´åˆ°æ‰¾åˆ°å­˜åœ¨çš„å›¾æ ‡æ–‡ä»¶
  for (const tryPath of possiblePaths) {
    if (fs.existsSync(tryPath)) {
      iconPath = tryPath;
      console.log(`æ‰¾åˆ°æ‰˜ç›˜å›¾æ ‡: ${iconPath}`);
      break;
    }
  }
  
  // å¦‚æœæ‰€æœ‰è·¯å¾„éƒ½ä¸å­˜åœ¨ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªè·¯å¾„ä½œä¸ºé»˜è®¤å€?  if (!iconPath) {
    iconPath = possiblePaths[0];
    console.warn(`è­¦å‘Š: æœªæ‰¾åˆ°æ‰˜ç›˜å›¾æ ‡æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤è·¯å¾„: ${iconPath}`);
  }
  
  try {
    tray = new Tray(iconPath);
    updateTrayMenu();
    tray.on('click', () => {
      mainWindow.isVisible() ? mainWindow.hide() : mainWindow.show();
    });
  } catch (error) {
    console.error('è®¾ç½®æ‰˜ç›˜å›¾æ ‡å¤±è´¥:', error);
    // å°è¯•åœ¨æ²¡æœ‰å›¾æ ‡çš„æƒ…å†µä¸‹åˆ›å»ºæ‰˜ç›?    try {
      console.log('å°è¯•åœ¨æ²¡æœ‰å›¾æ ‡çš„æƒ…å†µä¸‹åˆ›å»ºæ‰˜ç›?..');
      tray = new Tray(nativeImage.createEmpty());
      updateTrayMenu();
    } catch (fallbackError) {
      console.error('æ— æ³•åˆ›å»ºæ‰˜ç›˜:', fallbackError);
    }
  }
}

// æ›´æ–°æ‰˜ç›˜èœå•ï¼ŒåŒ…æ‹¬èŠ‚ç‚¹åˆ—è¡?async function updateTrayMenu() {
  if (!tray) return;
  
  try {
    // è·å–å½“å‰ä»£ç†çŠ¶æ€?    let proxyEnabled = systemProxyEnabled;
    
    // åŸºç¡€èœå•é¡?    const menuItems = [
      { label: 'æ˜¾ç¤ºä¸»çª—å?, click: () => mainWindow.show() },
      { type: 'separator' },
      { label: 'å¯ç”¨ç³»ç»Ÿä»£ç†', type: 'checkbox', checked: proxyEnabled, click: toggleSystemProxy },
      { 
        label: 'æ–­å¼€æ‰€æœ‰è¿æ?, 
        click: async () => {
          try {
            // ä½¿ç”¨Mihomo APIæ–­å¼€æ‰€æœ‰è¿æ?            const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
            const response = await fetch('http://127.0.0.1:9090/connections', {
              method: 'DELETE'
            });
            
            if (response.ok) {
              console.log('æˆåŠŸæ–­å¼€æ‰€æœ‰è¿æ?);
              // å¯é€‰ï¼šæ˜¾ç¤ºé€šçŸ¥
              if (mainWindow) {
                mainWindow.webContents.send('connections-closed');
              }
            } else {
              console.error(`æ–­å¼€æ‰€æœ‰è¿æ¥å¤±è´? ${response.statusText}`);
            }
          } catch (error) {
            console.error('æ–­å¼€æ‰€æœ‰è¿æ¥æ—¶å‡ºé”™:', error);
          }
        }
      }
    ];
    
    // å°è¯•è·å–èŠ‚ç‚¹åˆ—è¡¨
    let nodeMenuItems = [];
    
    try {
      // æ£€æŸ¥Mihomoæ˜¯å¦è¿è¡Œ
      const isServiceRunning = await checkMihomoService();
      if (isServiceRunning) {
        // ä½¿ç”¨fetch APIè·å–ä»£ç†èŠ‚ç‚¹ä¿¡æ¯
        const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
        
        // è·å–ä»£ç†èŠ‚ç‚¹ä¿¡æ¯
        const response = await fetch('http://127.0.0.1:9090/proxies');
        if (response.ok) {
          const data = await response.json();
          
          // è·å–æ‰€æœ‰ä»£ç†ç»„
          const proxyGroups = [];
          
          // æŸ¥æ‰¾æ‰€æœ‰ç±»å‹ä¸ºSelector, URLTest, Fallbackçš„ä»£ç†ç»„
          for (const [name, proxy] of Object.entries(data.proxies)) {
            if (proxy.type === 'Selector' || proxy.type === 'URLTest' || proxy.type === 'Fallback') {
              if (proxy.all && proxy.all.length > 0) {
                // å°†PROXYæˆ–GLOBALç»„æ”¾åœ¨æœ€å‰é¢
                if (name === 'PROXY' || name === 'GLOBAL') {
                  proxyGroups.unshift({
                    name: name,
                    type: proxy.type,
                    all: proxy.all,
                    now: proxy.now
                  });
                } else {
                  proxyGroups.push({
                    name: name,
                    type: proxy.type,
                    all: proxy.all,
                    now: proxy.now
                  });
                }
              }
            }
          }
          
          // åˆ›å»ºæ‰€æœ‰ä»£ç†ç»„çš„å­èœå•
          if (proxyGroups.length > 0) {
            const groupSubmenuItems = [];
            
            // ä¸ºæ¯ä¸ªä»£ç†ç»„åˆ›å»ºå­èœå?            for (const group of proxyGroups) {
              const nodesSubmenu = [];
              
              // å…ˆå¯¹èŠ‚ç‚¹è¿›è¡Œæ’åº - å°†å½“å‰é€‰ä¸­èŠ‚ç‚¹å’Œæœ‰å»¶è¿Ÿä¿¡æ¯çš„èŠ‚ç‚¹æ’åœ¨å‰é?              const sortedNodeNames = [...group.all].sort((a, b) => {
                // å½“å‰é€‰ä¸­çš„èŠ‚ç‚¹æ’åœ¨æœ€å‰é¢
                if (a === group.now) return -1;
                if (b === group.now) return 1;
                
                const nodeA = data.proxies[a];
                const nodeB = data.proxies[b];
                
                // æœ‰å»¶è¿Ÿä¿¡æ¯çš„èŠ‚ç‚¹ä¼˜å…ˆ
                const delayA = nodeA?.history?.[0]?.delay ?? -1;
                const delayB = nodeB?.history?.[0]?.delay ?? -1;
                
                // éƒ½æœ‰å»¶è¿Ÿä¿¡æ¯ï¼ŒæŒ‰å»¶è¿Ÿä»å°åˆ°å¤§æ’åº
                if (delayA > 0 && delayB > 0) return delayA - delayB;
                
                // æœ‰å»¶è¿Ÿä¿¡æ¯çš„æ’åœ¨å‰é¢
                if (delayA > 0) return -1;
                if (delayB > 0) return 1;
                
                // éƒ½æ²¡æœ‰å»¶è¿Ÿä¿¡æ¯ï¼ŒæŒ‰å­—æ¯é¡ºåºæ’åº?                return a.localeCompare(b);
              });
              
              // ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ›å»ºèœå•é¡¹
              for (const nodeName of sortedNodeNames) {
                const node = data.proxies[nodeName];
                if (node) {
                  // è·³è¿‡å…¶ä»–ä»£ç†ç»„ç±»å‹ï¼ˆä¸è·³è¿‡ï¼Œéƒ¨åˆ†é…ç½®å…è®¸ä»£ç†ç»„åµŒå¥—ï¼‰
                  // if (node.type === 'Selector' || node.type === 'URLTest' || node.type === 'Fallback') {
                  //   continue;
                  // }
                  
                  let label = nodeName;
                  // æ·»åŠ å»¶è¿Ÿæ˜¾ç¤ºï¼ˆå¦‚æœæœ‰ï¼?                  if (node.history && node.history.length > 0) {
                    const delay = node.history[0].delay;
                    if (delay > 0) {
                      label = `${nodeName} (${delay}ms)`;
                    } else if (delay === 0) {
                      label = `${nodeName} (è¶…æ—¶)`;
                    }
                  }
                  
                  // å¦‚æœæ˜¯ä»£ç†ç»„ï¼Œæ·»åŠ æ ‡è®?                  if (node.type === 'Selector' || node.type === 'URLTest' || node.type === 'Fallback') {
                    label = `${label} [ç»„]`;
                  }
                  
                  nodesSubmenu.push({
                    label: label,
                    type: 'radio',
                    checked: nodeName === group.now,
                    click: async () => {
                      // è°ƒç”¨APIåˆ‡æ¢èŠ‚ç‚¹
                      try {
                        // åˆ‡æ¢èŠ‚ç‚¹
                        const switchResponse = await fetch(`http://127.0.0.1:9090/proxies/${encodeURIComponent(group.name)}`, {
                          method: 'PUT',
                          headers: {
                            'Content-Type': 'application/json'
                          },
                          body: JSON.stringify({ name: nodeName })
                        });
                        
                        if (switchResponse.ok) {
                          console.log(`æˆåŠŸåˆ‡æ¢ç»?${group.name} åˆ°èŠ‚ç‚? ${nodeName}`);
                          
                          // å¦‚æœæ˜¯ä¸»è¦ç»„ï¼ˆPROXYæˆ–GLOBALï¼‰ï¼ŒåŒæ—¶æ›´æ–°å½“å‰èŠ‚ç‚¹
                          if (group.name === 'PROXY' || group.name === 'GLOBAL') {
                            // åˆ‡æ¢æˆåŠŸåæ›´æ–°UI
                            if (mainWindow) {
                              mainWindow.webContents.send('node-changed', { nodeName });
                            }
                            // æ›´æ–°å½“å‰èŠ‚ç‚¹
                            currentNode = nodeName;
                            // æ›´æ–°æ‰˜ç›˜æç¤º
                            tray.setToolTip(`FlyClash - ${nodeName}`);
                          }
                          
                          // æ›´æ–°æ‰˜ç›˜èœå•
                          setTimeout(() => updateTrayMenu(), 1000);
                        } else {
                          console.error(`åˆ‡æ¢èŠ‚ç‚¹å¤±è´¥: ${switchResponse.statusText}`);
                        }
                      } catch (error) {
                        console.error('åˆ‡æ¢èŠ‚ç‚¹å¤±è´¥:', error);
                      }
                    }
                  });
                }
              }
              
              // å¦‚æœæœ‰èŠ‚ç‚¹ï¼Œæ·»åŠ åˆ°ä»£ç†ç»„èœå•
              if (nodesSubmenu.length > 0) {
                // æ ‡è®°å½“å‰é€‰ä¸­çš„èŠ‚ç‚?                const groupLabel = group.name === 'PROXY' || group.name === 'GLOBAL' 
                  ? `${group.name} â˜…` 
                  : group.name;
                
                groupSubmenuItems.push({
                  label: groupLabel,
                  submenu: nodesSubmenu
                });
              }
            }
            
            // æ·»åŠ æ‰€æœ‰ä»£ç†ç»„èœå•
            nodeMenuItems = [
              { type: 'separator' },
              { 
                label: 'èŠ‚ç‚¹é€‰æ‹©', 
                submenu: groupSubmenuItems
              }
            ];
          }
        }
      }
    } catch (error) {
      console.error('è·å–èŠ‚ç‚¹åˆ—è¡¨å¤±è´¥:', error);
    }
    
    // ç»„åˆå®Œæ•´èœå•
    const contextMenu = Menu.buildFromTemplate([
      ...menuItems,
      ...nodeMenuItems,
      { type: 'separator' },
      { label: 'é€€å‡?, click: () => {
        isQuitting = true;
        app.quit();
      }}
    ]);
    
    tray.setContextMenu(contextMenu);
    
    // æ›´æ–°æ‰˜ç›˜æç¤ºï¼Œæ˜¾ç¤ºå½“å‰èŠ‚ç‚?    if (currentNode) {
      tray.setToolTip(`FlyClash - ${currentNode}`);
    } else {
      tray.setToolTip('FlyClash');
    }
  } catch (error) {
    console.error('æ›´æ–°æ‰˜ç›˜èœå•å¤±è´¥:', error);
    // åˆ›å»ºåŸºæœ¬èœå•ä½œä¸ºåå¤‡
    const basicMenu = Menu.buildFromTemplate([
      { label: 'æ˜¾ç¤ºä¸»çª—å?, click: () => mainWindow.show() },
      { type: 'separator' },
      { label: 'é€€å‡?, click: () => {
        isQuitting = true;
        app.quit();
      }}
    ]);
    tray.setContextMenu(basicMenu);
  }
}

// ç³»ç»Ÿä»£ç†çŠ¶æ€?let systemProxyEnabled = false;

// åˆ‡æ¢ç³»ç»Ÿä»£ç†
function toggleSystemProxy(menuItem) {
  // æ£€æŸ¥mihomoæ˜¯å¦è¿è¡Œä¸?  if (!mihomoProcess) {
    dialog.showErrorBox('é”™è¯¯', 'è¯·å…ˆå¯åŠ¨ä»£ç†æœåŠ¡');
    return;
  }
  
  try {
    // è¯»å–å½“å‰ç”¨æˆ·è®¾ç½®ï¼Œè·å–æœ€æ–°çš„ç«¯å£è®¾ç½®
    const userSettings = getUserSettings();
    const port = userSettings['mixed-port'] || 7890;
    
    if (menuItem.checked) {
      // å¯ç”¨ç³»ç»Ÿä»£ç†
      console.log('å¯ç”¨ç³»ç»Ÿä»£ç†ï¼Œç«¯å?', port);
      
      // Windowså¹³å°
      if (process.platform === 'win32') {
        // Windows ä½¿ç”¨ Internet è®¾ç½®æ³¨å†Œè¡?        execSync('reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyEnable /t REG_DWORD /d 1 /f');
        execSync(`reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyServer /t REG_SZ /d "127.0.0.1:${port}" /f`);
        
        // è®¾ç½®ç¯å¢ƒå˜é‡
        process.env.HTTP_PROXY = `http://127.0.0.1:${port}`;
        process.env.HTTPS_PROXY = `http://127.0.0.1:${port}`;
      } 
      // macOSå¹³å°ä½¿ç”¨networksetupå‘½ä»¤
      else if (process.platform === 'darwin') {
        // è·å–æ‰€æœ‰æ´»åŠ¨ç½‘ç»œæœåŠ?        const services = execSync('networksetup -listallnetworkservices').toString().split('\n');
        // è·³è¿‡ç¬¬ä¸€è¡?æ ‡é¢˜è¡?
        for (let i = 1; i < services.length; i++) {
          const service = services[i].trim();
          if (service && !service.includes('*')) {
            execSync(`networksetup -setwebproxy "${service}" 127.0.0.1 ${port}`);
            execSync(`networksetup -setsecurewebproxy "${service}" 127.0.0.1 ${port}`);
            execSync(`networksetup -setsocksfirewallproxy "${service}" 127.0.0.1 ${port}`);
          }
        }
      }
      
      systemProxyEnabled = true;
      if (mainWindow) {
        mainWindow.webContents.send('proxy-status', true);
      }
    } else {
      // ç¦ç”¨ç³»ç»Ÿä»£ç†
      console.log('ç¦ç”¨ç³»ç»Ÿä»£ç†');
      
      // Windowså¹³å°
      if (process.platform === 'win32') {
        // Windows ä½¿ç”¨ Internet è®¾ç½®æ³¨å†Œè¡?        execSync('reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyEnable /t REG_DWORD /d 0 /f');
        
        // æ¸…é™¤ç¯å¢ƒå˜é‡
        delete process.env.HTTP_PROXY;
        delete process.env.HTTPS_PROXY;
      } 
      // macOSå¹³å°
      else if (process.platform === 'darwin') {
        const services = execSync('networksetup -listallnetworkservices').toString().split('\n');
        for (let i = 1; i < services.length; i++) {
          const service = services[i].trim();
          if (service && !service.includes('*')) {
            execSync(`networksetup -setwebproxystate "${service}" off`);
            execSync(`networksetup -setsecurewebproxystate "${service}" off`);
            execSync(`networksetup -setsocksfirewallproxystate "${service}" off`);
          }
        }
      }
      
      systemProxyEnabled = false;
      if (mainWindow) {
        mainWindow.webContents.send('proxy-status', false);
      }
    }
  } catch (error) {
    console.error('è®¾ç½®ç³»ç»Ÿä»£ç†å¤±è´¥:', error);
    dialog.showErrorBox('ç³»ç»Ÿä»£ç†é”™è¯¯', `è®¾ç½®ç³»ç»Ÿä»£ç†å¤±è´¥: ${error.message}`);
    
    // æ¢å¤èœå•é¡¹çŠ¶æ€?    menuItem.checked = !menuItem.checked;
    systemProxyEnabled = !menuItem.checked;
    
    if (mainWindow) {
      mainWindow.webContents.send('proxy-status', systemProxyEnabled);
    }
  }
}

// æ›´æ–°ç³»ç»Ÿä»£ç†è®¾ç½®ï¼ˆå½“ç«¯å£å˜æ›´æ—¶è°ƒç”¨ï¼‰
function updateSystemProxyIfEnabled() {
  // å¦‚æœç³»ç»Ÿä»£ç†æœªå¯ç”¨ï¼Œåˆ™ä¸éœ€è¦æ›´æ–?  if (!systemProxyEnabled) {
    return;
  }
  
  try {
    // è¯»å–å½“å‰ç”¨æˆ·è®¾ç½®ï¼Œè·å–æœ€æ–°çš„ç«¯å£è®¾ç½®
    const userSettings = getUserSettings();
    const port = userSettings['mixed-port'] || 7890;
    
    console.log('æ›´æ–°ç³»ç»Ÿä»£ç†è®¾ç½®ï¼Œä½¿ç”¨æ–°ç«¯å£:', port);
    
    // Windowså¹³å°
    if (process.platform === 'win32') {
      // Windows ä½¿ç”¨ Internet è®¾ç½®æ³¨å†Œè¡?      execSync('reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyEnable /t REG_DWORD /d 1 /f');
      execSync(`reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyServer /t REG_SZ /d "127.0.0.1:${port}" /f`);
      
      // æ›´æ–°ç¯å¢ƒå˜é‡
      process.env.HTTP_PROXY = `http://127.0.0.1:${port}`;
      process.env.HTTPS_PROXY = `http://127.0.0.1:${port}`;
    } 
    // macOSå¹³å°
    else if (process.platform === 'darwin') {
      const services = execSync('networksetup -listallnetworkservices').toString().split('\n');
      for (let i = 1; i < services.length; i++) {
        const service = services[i].trim();
        if (service && !service.includes('*')) {
          execSync(`networksetup -setwebproxy "${service}" 127.0.0.1 ${port}`);
          execSync(`networksetup -setsecurewebproxy "${service}" 127.0.0.1 ${port}`);
          execSync(`networksetup -setsocksfirewallproxy "${service}" 127.0.0.1 ${port}`);
        }
      }
    }
    
    console.log('ç³»ç»Ÿä»£ç†è®¾ç½®å·²æ›´æ–?);
  } catch (error) {
    console.error('æ›´æ–°ç³»ç»Ÿä»£ç†è®¾ç½®å¤±è´¥:', error);
    dialog.showErrorBox('ç³»ç»Ÿä»£ç†é”™è¯¯', `æ›´æ–°ç³»ç»Ÿä»£ç†è®¾ç½®å¤±è´¥: ${error.message}`);
  }
}

// è‡ªåŠ¨å¯åŠ¨MihomoåŠŸèƒ½
async function autoStartMihomo() {
  try {
    // è·å–ä¿å­˜çš„è®¢é˜…åˆ—è¡?    const subscriptions = await getSubscriptionList();
    if (subscriptions.length === 0) {
      console.log('æ²¡æœ‰å¯ç”¨çš„é…ç½®æ–‡ä»¶ï¼Œæ— æ³•è‡ªåŠ¨å¯åŠ¨');
      return;
    }
    
    // å°è¯•ä»å­˜å‚¨ä¸­è¯»å–ä¸Šæ¬¡ä½¿ç”¨çš„é…ç½®æ–‡ä»¶è·¯å¾?    let configPath;
    try {
      const lastConfigPath = path.join(userDataPath, 'last-config.json');
      if (fs.existsSync(lastConfigPath)) {
        const lastConfig = JSON.parse(fs.readFileSync(lastConfigPath, 'utf8'));
        if (lastConfig.path && fs.existsSync(lastConfig.path)) {
          console.log('æ‰¾åˆ°ä¸Šæ¬¡ä½¿ç”¨çš„é…ç½®æ–‡ä»?', lastConfig.path);
          configPath = lastConfig.path;
        }
      }
    } catch (error) {
      console.error('è¯»å–ä¸Šæ¬¡é…ç½®æ–‡ä»¶å¤±è´¥:', error);
    }
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä¸Šæ¬¡çš„é…ç½®æˆ–æ–‡ä»¶ä¸å­˜åœ¨ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„é…ç½®
    if (!configPath) {
      configPath = subscriptions[0].path;
      console.log('æ²¡æœ‰æ‰¾åˆ°ä¸Šæ¬¡çš„é…ç½®ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªé…ç½®æ–‡ä»?', configPath);
    }
    
    const success = await startMihomo(configPath);
    
    if (success && mainWindow) {
      // é€šçŸ¥å‰ç«¯æ›´æ–°çŠ¶æ€?      mainWindow.webContents.send('mihomo-autostart', {
        success: true,
        configPath: configPath
      });
      
      // è‡ªåŠ¨åº”ç”¨ä¸Šæ¬¡çš„ä»£ç†çŠ¶æ€?      try {
        const proxyConfigPath = path.join(userDataPath, 'proxy-config.json');
        if (fs.existsSync(proxyConfigPath)) {
          const proxyConfig = JSON.parse(fs.readFileSync(proxyConfigPath, 'utf8'));
          console.log('åº”ç”¨ä¸Šæ¬¡ä¿å­˜çš„ä»£ç†çŠ¶æ€?', proxyConfig.enabled);
          
          if (proxyConfig.enabled) {
            // å¯ç”¨ç³»ç»Ÿä»£ç†
            execSync('reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyEnable /t REG_DWORD /d 1 /f');
            execSync('reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyServer /t REG_SZ /d "127.0.0.1:7890" /f');
            mainWindow.webContents.send('proxy-status', true);
          } else {
            // ç¦ç”¨ç³»ç»Ÿä»£ç†
            execSync('reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyEnable /t REG_DWORD /d 0 /f');
            mainWindow.webContents.send('proxy-status', false);
          }
        }
      } catch (error) {
        console.error('åº”ç”¨ä¸Šæ¬¡ä»£ç†çŠ¶æ€å¤±è´?', error);
      }
    }
  } catch (error) {
    console.error('è‡ªåŠ¨å¯åŠ¨Mihomoå¤±è´¥:', error);
    if (mainWindow) {
      mainWindow.webContents.send('mihomo-autostart', {
        success: false,
        error: error.message
      });
    }
  }
}

// è·å–è®¢é˜…åˆ—è¡¨
function getSubscriptionList() {
  return new Promise((resolve) => {
    if (!fs.existsSync(configDir)) {
      resolve([]);
      return;
    }
    
    const subscriptions = fs.readdirSync(configDir)
      .filter(file => file.endsWith('.yaml'))
      .map(file => ({
        name: file.replace('.yaml', ''),
        path: path.join(configDir, file)
      }));
    
    resolve(subscriptions);
  });
}

// è§£æYAMLé…ç½®æ–‡ä»¶
function parseConfigFile(filePath) {
  try {
    const fileContent = fs.readFileSync(filePath, 'utf8');
    
    // ä½¿ç”¨js-yamlè§£æ
    let yaml;
    try {
      yaml = require('js-yaml');
    } catch (e) {
      console.error('js-yamlæ¨¡å—æœªå®‰è£…ï¼Œæ— æ³•è§£æé…ç½®');
      return null;
    }
    
    const config = yaml.load(fileContent);
    if (!config) {
      return null;
    }
    
    // æå–æ‰€æœ‰ä»£ç†ç»„å’ŒèŠ‚ç‚¹ï¼Œä¿æŒåŸå§‹é¡ºåº
    const proxyGroups = [];
    
    if (config["proxy-groups"] && Array.isArray(config["proxy-groups"])) {
      for (const group of config["proxy-groups"]) {
        if (group.name && (group.type === 'select' || group.type === 'url-test' || group.type === 'fallback')) {
          proxyGroups.push({
            name: group.name,
            type: group.type,
            proxies: group.proxies || []
          });
        }
      }
    }
    
    // æå–æ‰€æœ‰ä»£ç†èŠ‚ç‚?    const proxies = [];
    if (config.proxies && Array.isArray(config.proxies)) {
      for (const proxy of config.proxies) {
        if (proxy.name) {
          proxies.push({
            name: proxy.name,
            type: proxy.type,
            server: proxy.server || '',
            port: proxy.port || 0
          });
        }
      }
    }
    
      return {
      proxyGroups,
      proxies
    };
  } catch (error) {
    console.error('è§£æé…ç½®æ–‡ä»¶å¤±è´¥:', error);
    return null;
  }
}

// æ–°å¢: è·å–é…ç½®æ–‡ä»¶ä¸­çš„åŸå§‹ä»£ç†ç»„é¡ºåº?ipcMain.handle('get-config-order', async (event) => {
  try {
    // å¦‚æœMihomoæœªè¿è¡Œï¼Œæ²¡æœ‰æ´»è·ƒçš„é…ç½®æ–‡ä»?    if (!configFilePath) {
            return {
        success: false,
        error: 'Mihomoæœªè¿è¡Œï¼Œæ²¡æœ‰æ´»è·ƒçš„é…ç½®æ–‡ä»?
      };
    }
    
    // è§£æé…ç½®æ–‡ä»¶
    const configData = parseConfigFile(configFilePath);
    if (!configData) {
      return {
        success: false,
        error: 'è§£æé…ç½®æ–‡ä»¶å¤±è´¥'
      };
    }
    
    return {
      success: true,
      data: configData
    };
  } catch (error) {
    console.error('è·å–é…ç½®é¡ºåºå¤±è´¥:', error);
    return {
      success: false,
      error: `è·å–é…ç½®é¡ºåºå¤±è´¥: ${error.message}`
    };
  }
});

// æ–°å¢: è·å–å½“å‰é…ç½®
async function getConfig() {
  try {
    if (!configFilePath || !fs.existsSync(configFilePath)) {
      console.log('å½“å‰æ²¡æœ‰æ´»è·ƒçš„é…ç½®æ–‡ä»?);
      return null;
    }
    
    // è¯»å–é…ç½®æ–‡ä»¶
    const content = fs.readFileSync(configFilePath, 'utf8');
    
    if (!content || content.trim() === '') {
      console.error('é…ç½®æ–‡ä»¶ä¸ºç©º');
      return null;
    }
    
    // è§£æYAML
    const config = yaml.load(content);
    
    if (!config) {
      console.error('è§£æé…ç½®æ–‡ä»¶å¤±è´¥');
      return null;
    }
    
    return config;
  } catch (error) {
    console.error('è·å–é…ç½®å¤±è´¥:', error);
    return null;
  }
}

// æ›´æ–°æµé‡ç»Ÿè®¡
function updateTrafficStats() {
  // å¦‚æœWebSocketå·²ç»è¿æ¥ï¼Œä¸éœ€è¦é‡æ–°è¿æ?  if (trafficWebSocket && trafficWebSocket.readyState === 1) { // 1 = OPEN
    return;
  }

  // ä½¿ç”¨æ ‡å‡†çš„WebSocketåœ°å€
  const wsUrl = 'ws://127.0.0.1:9090/traffic';
  
  // åˆ›å»ºæµé‡ç»Ÿè®¡WebSocket
  trafficWebSocket = new WebSocket(wsUrl);

  trafficWebSocket.on('open', () => {
    console.log('æµé‡ç»Ÿè®¡WebSocketè¿æ¥å·²å»ºç«?);
    trafficRetry = 10; // é‡ç½®é‡è¯•è®¡æ•°
  });

  trafficWebSocket.on('message', (data) => {
    try {
      const json = JSON.parse(data);
      
      // ç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®
      if (!json || typeof json.up !== 'number' || typeof json.down !== 'number') {
        console.error('æ— æ•ˆçš„æµé‡æ•°æ®æ ¼å¼?);
        return;
      }

      // æ›´æ–°ç»Ÿè®¡æ•°æ®
      const stats = {
        up: json.up,
        down: json.down,
        timestamp: Date.now(),
        upSpeed: json.up,
        downSpeed: json.down
      };

      lastTrafficStats = stats;
      
      // å‘é€æ›´æ–°åˆ°ä¸»çª—å?      if (mainWindow) {
        mainWindow.webContents.send('traffic-update', stats);
      }
      
      // æ¯å½“æ”¶åˆ°æµé‡æ›´æ–°æ—¶ï¼ŒåŒæ—¶è·å–æ€»æµé‡æ•°æ?      fetchConnectionsInfo();
      
      // åªåœ¨æµé‡å˜åŒ–è¾ƒå¤§æ—¶è¾“å‡ºæ—¥å¿—ï¼ˆå¤§äº10MBçš„å˜åŒ–ï¼‰
      const significantChange = Math.abs(stats.up - lastTrafficStats.up) > 10 * 1024 * 1024 || 
                               Math.abs(stats.down - lastTrafficStats.down) > 10 * 1024 * 1024;
      if (significantChange) {
        console.log(`æµé‡æ›´æ–°: ä¸Šä¼  ${formatTraffic(stats.up)}, ä¸‹è½½ ${formatTraffic(stats.down)}`);
      }
    } catch (error) {
      console.error('å¤„ç†æµé‡æ•°æ®æ—¶å‡ºé”?', error);
    }
  });

  trafficWebSocket.on('close', () => {
    // åªåœ¨ç¬¬ä¸€æ¬¡å…³é—­æ—¶è¾“å‡ºæ—¥å¿—
    if (trafficRetry === 10) {
      console.log('æµé‡ç»Ÿè®¡WebSocketè¿æ¥å·²å…³é—?);
    }
    trafficWebSocket = null;

    if (trafficRetry > 0) {
      trafficRetry--;
      // åªåœ¨ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡é‡è¯•æ—¶è¾“å‡ºæ—¥å¿—
      if (trafficRetry === 9 || trafficRetry === 0) {
        console.log(`å°è¯•é‡æ–°è¿æ¥WebSocketï¼Œå‰©ä½™é‡è¯•æ¬¡æ•? ${trafficRetry}`);
      }
      updateTrafficStats();
    } else {
      console.log('WebSocketé‡è¿æ¬¡æ•°å·²è¾¾ä¸Šé™ï¼Œåœæ­¢é‡è¯?);
    }
  });

  trafficWebSocket.on('error', (error) => {
    console.error('æµé‡ç»Ÿè®¡WebSocketé”™è¯¯:', error);
    if (trafficWebSocket) {
      trafficWebSocket.close();
      trafficWebSocket = null;
    }
  });
}

// è®¾ç½®å®šæ—¶æ›´æ–°æµé‡ç»Ÿè®¡
let trafficStatsInterval;
function startTrafficStatsUpdate() {
  if (trafficStatsInterval) {
    clearInterval(trafficStatsInterval);
  }
  
  // åˆå§‹åŒ–WebSocketè¿æ¥
  updateTrafficStats();
  
  // è®¾ç½®å®šæ—¶å™¨ï¼Œæ¯?ç§’æ£€æŸ¥ä¸€æ¬¡WebSocketè¿æ¥çŠ¶æ€?  trafficStatsInterval = setInterval(() => {
    if (!trafficWebSocket || trafficWebSocket.readyState !== 1) {
      // ç§»é™¤é‡è¿æ—¥å¿—ï¼Œé¿å…åˆ·å±?      updateTrafficStats();
    }
  }, 1000); // æ¯?ç§’æ£€æŸ¥ä¸€æ¬?}

function stopTrafficStatsUpdate() {
  if (trafficStatsInterval) {
    clearInterval(trafficStatsInterval);
    trafficStatsInterval = null;
  }
  
  if (trafficWebSocket) {
    trafficWebSocket.close();
    trafficWebSocket = null;
  }
}

// å¯åŠ¨è¿æ¥ç®¡ç†WebSocket
async function startConnectionsWebSocket() {
  try {
    if (!currentNode) {
      throw new Error('æœªé€‰æ‹©èŠ‚ç‚¹');
    }

    // åˆ›å»ºæ–°çš„WebSocketè¿æ¥
    connectionsWebSocket = new WebSocket(`ws://localhost:8080/connections/${currentNode}`);
    
    // è®¾ç½®è¿æ¥è¶…æ—¶
    const connectionTimeout = setTimeout(() => {
      if (connectionsWebSocket.readyState !== WebSocket.OPEN) {
        connectionsWebSocket.close();
        throw new Error('è¿æ¥è¶…æ—¶');
      }
    }, 5000);

    // è¿æ¥å»ºç«‹
    connectionsWebSocket.on('open', () => {
      clearTimeout(connectionTimeout);
      console.log(`å·²è¿æ¥åˆ°èŠ‚ç‚¹ ${currentNode}`);
    });

    // è¿æ¥å…³é—­
    connectionsWebSocket.on('close', () => {
      console.log(`ä¸èŠ‚ç‚?${currentNode} çš„è¿æ¥å·²å…³é—­`);
      // å°è¯•é‡æ–°è¿æ¥
      setTimeout(() => {
        if (currentNode) {
          startConnectionsWebSocket().catch(console.error);
        }
      }, 5000);
    });

    // é”™è¯¯å¤„ç†
    connectionsWebSocket.on('error', (error) => {
      console.error('WebSocketé”™è¯¯:', error);
      clearTimeout(connectionTimeout);
    });

  } catch (error) {
    console.error('å¯åŠ¨WebSocketè¿æ¥å¤±è´¥:', error);
    throw error;
  }
}

// æ›´æ–°å½“å‰èŠ‚ç‚¹ä¿¡æ¯
async function updateCurrentNodeInfo() {
  try {
    // ä½¿ç”¨æ­£ç¡®çš„APIç«¯ç‚¹è·å–PROXYç»„ä¿¡æ?    const response = await fetch('http://127.0.0.1:9090/proxies/PROXY');
    if (response.ok) {
      const data = await response.json();
      console.log('è·å–åˆ°PROXYç»„ä¿¡æ?', data);
      
      if (data && data.now) {
        currentNode = data.now;
        console.log('æ›´æ–°å½“å‰èŠ‚ç‚¹ä¸?', currentNode);
        
        // æ›´æ–°lastConnectionsInfoä¸­çš„èŠ‚ç‚¹ä¿¡æ¯
        lastConnectionsInfo = {
          ...lastConnectionsInfo,
          currentNode: currentNode
        };
        
        // é€šçŸ¥ä¸»çª—å£èŠ‚ç‚¹å·²æ›´æ–°
        if (mainWindow && mainWindow.webContents && !mainWindow.isDestroyed()) {
          console.log('å‘é€èŠ‚ç‚¹å˜æ›´äº‹ä»?', currentNode);
          
          // ç«‹å³å‘é€èŠ‚ç‚¹æ›´æ–?          mainWindow.webContents.send('node-changed', { nodeName: currentNode });
          
          // æ·»åŠ å»¶è¿Ÿï¼Œç¡®ä¿å‰ç«¯æœ‰è¶³å¤Ÿæ—¶é—´å¤„ç†èŠ‚ç‚¹æ›´æ–°
          setTimeout(() => {
            if (mainWindow && !mainWindow.isDestroyed()) {
              console.log('å»¶è¿Ÿå‘é€è¿æ¥ä¿¡æ¯æ›´æ–?', lastConnectionsInfo);
              mainWindow.webContents.send('connections-update', lastConnectionsInfo);
            }
          }, 500);
        } else {
          console.warn('ä¸»çª—å£æœªå‡†å¤‡å¥½ï¼Œæ— æ³•å‘é€èŠ‚ç‚¹å˜æ›´äº‹ä»?);
        }
      } else {
        console.error('PROXYç»„ä¿¡æ¯ä¸­æ²¡æœ‰nowå­—æ®µ:', data);
      }
    } else {
      console.error('è·å–PROXYç»„ä¿¡æ¯å¤±è´?', response.status, response.statusText);
    }
  } catch (error) {
    console.error('è·å–å½“å‰èŠ‚ç‚¹ä¿¡æ¯å¤±è´¥:', error);
  }
}

// åœæ­¢è¿æ¥ç®¡ç†WebSocket
function stopConnectionsWebSocket() {
  if (connectionsWebSocket) {
    connectionsWebSocket.close();
    connectionsWebSocket = null;
  }
  connectionsRetry = 10;
}

// æ·»åŠ æ£€æŸ¥MihomoæœåŠ¡çŠ¶æ€çš„å‡½æ•°
async function checkMihomoService() {
  try {
    const response = await fetch('http://127.0.0.1:9090/proxies');
    if (response.ok) {
      return true;
    }
    return false;
  } catch (error) {
    console.error('[DEBUG] MihomoæœåŠ¡æ£€æŸ¥å¤±è´?', error);
    return false;
  }
}

// Mihomoè¿›ç¨‹æ„å¤–åœæ­¢æ—¶çš„å¤„ç†å‡½æ•°
function handleMihomoProcessExit(code) {
  console.log(`Mihomoè¿›ç¨‹é€€å‡ºï¼Œä»£ç : ${code}`);
  mihomoProcess = null;
  stopTrafficStatsUpdate();
  stopConnectionsWebSocket();
  // æ¸…é™¤configFilePathç¡®ä¿çŠ¶æ€æ­£ç¡®æ›´æ–?  configFilePath = null;
  
  // é€šçŸ¥å‰ç«¯Mihomoå·²åœæ­?  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send('mihomo-stopped', code);
  }
}

app.whenReady().then(() => {
  // åŠ è½½ä¸»é¢˜è®¾ç½®
  try {
    const themeConfigPath = path.join(userDataPath, 'theme-config.json');
    if (fs.existsSync(themeConfigPath)) {
      const themeConfig = JSON.parse(fs.readFileSync(themeConfigPath, 'utf8'));
      nativeTheme.themeSource = themeConfig.theme || 'system';
      console.log('å·²åŠ è½½ä¸»é¢˜è®¾ç½?', themeConfig.theme);
    }
  } catch (error) {
    console.error('åŠ è½½ä¸»é¢˜è®¾ç½®å¤±è´¥:', error);
  }

  // ç¡®ä¿ç”¨æˆ·è®¾ç½®æ–‡ä»¶å­˜åœ¨
  ensureUserSettingsFile();
  
  // æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å·²ç»å¯ç”¨ä»£ç?  try {
    if (process.platform === 'win32') {
      const result = execSync('reg query "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyEnable').toString();
      systemProxyEnabled = result.includes('0x1');
      
      if (systemProxyEnabled) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯æˆ‘ä»¬çš„ä»£ç†è®¾ç½?        const serverResult = execSync('reg query "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyServer').toString();
        if (serverResult.includes('127.0.0.1:')) {
          console.log('ç³»ç»Ÿä»£ç†å·²å¯ç”?', serverResult);
        } else {
          console.log('ç³»ç»Ÿä»£ç†å·²å¯ç”¨ï¼Œä½†ä½¿ç”¨çš„ä¸æ˜¯æˆ‘ä»¬çš„è®¾ç½?', serverResult);
        }
      } else {
        console.log('ç³»ç»Ÿä»£ç†æœªå¯ç”?);
      }
    }
  } catch (error) {
    console.error('æ£€æŸ¥ç³»ç»Ÿä»£ç†çŠ¶æ€å¤±è´?', error);
  }

  createWindow();
  setupTray();
  
  // æ³¨å†ŒAPI: ä¿å­˜ä»£ç†è®¾ç½®
  ipcMain.handle('save-proxy-settings', async (event, settings) => {
    try {
      console.log('ä¿å­˜ä»£ç†è®¾ç½®:', settings);
      
      // éªŒè¯è®¾ç½®
      if (settings['mixed-port']) {
        const port = parseInt(settings['mixed-port'], 10);
        if (isNaN(port) || port < 1024 || port > 65535) {
          return { success: false, error: 'ç«¯å£å·å¿…é¡»æ˜¯1024-65535ä¹‹é—´çš„æœ‰æ•ˆæ•°å­? };
        }
        settings['mixed-port'] = port;
      }
      
      if ('allow-lan' in settings) {
        settings['allow-lan'] = Boolean(settings['allow-lan']);
      }
      
      if ('ipv6' in settings) {
        settings['ipv6'] = Boolean(settings['ipv6']);
      }
      
      // æ›´æ–°ç”¨æˆ·è®¾ç½®æ–‡ä»¶
      if (updateUserSettings(settings)) {
        // å¦‚æœç³»ç»Ÿä»£ç†å·²å¯ç”¨ï¼Œåˆ™æ›´æ–°ç³»ç»Ÿä»£ç†è®¾ç½?        updateSystemProxyIfEnabled();
        
        // å¦‚æœæœåŠ¡æ­£åœ¨è¿è¡Œï¼Œåˆ™éœ€è¦é‡å¯æœåŠ?        if (mihomoProcess) {
          // å­˜å‚¨å½“å‰é…ç½®è·¯å¾„
          const currentConfig = configFilePath;
          // åœæ­¢æœåŠ¡
          mihomoProcess.kill();
          mihomoProcess = null;
          // é‡å¯æœåŠ¡
          await startMihomo(currentConfig);
          
          return { success: true, message: 'è®¾ç½®å·²ä¿å­˜ï¼ŒæœåŠ¡å·²é‡å? };
        }
        
        return { success: true, message: 'è®¾ç½®å·²ä¿å­? };
      } else {
        return { success: false, error: 'ä¿å­˜è®¾ç½®å¤±è´¥' };
      }
    } catch (error) {
      console.error('ä¿å­˜ä»£ç†è®¾ç½®å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  // æ³¨å†ŒAPI: è·å–å½“å‰ä»£ç†è®¾ç½®
  ipcMain.handle('get-proxy-settings', async () => {
    try {
      const settings = getUserSettings();
      return { success: true, settings };
    } catch (error) {
      console.error('è·å–ä»£ç†è®¾ç½®å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  // æ·»åŠ : ä¸»é¢˜è®¾ç½®
  ipcMain.handle('set-theme', (event, theme) => {
    try {
      console.log('è®¾ç½®ä¸»é¢˜:', theme);
      if (!mainWindow || mainWindow.isDestroyed()) {
        return { success: false, error: 'çª—å£ä¸å­˜åœ? };
      }

      // ä¿å­˜ä¸»é¢˜è®¾ç½®åˆ°é…ç½®æ–‡ä»?      const themeConfigPath = path.join(userDataPath, 'theme-config.json');
      fs.writeFileSync(themeConfigPath, JSON.stringify({ theme }), 'utf8');
      
      // æ ¹æ®ä¸»é¢˜æ›´æ–°çª—å£
      switch (theme) {
        case 'light':
          nativeTheme.themeSource = 'light';
          mainWindow.webContents.send('theme-changed', 'light');
          break;
        case 'dark':
          nativeTheme.themeSource = 'dark';
          mainWindow.webContents.send('theme-changed', 'dark');
          break;
        case 'system':
        default:
          nativeTheme.themeSource = 'system';
          mainWindow.webContents.send('theme-changed', nativeTheme.shouldUseDarkColors ? 'dark' : 'light');
          break;
      }

      // æ›´æ–°æ ‡é¢˜æ é¢œè‰?      mainWindow.setTitleBarOverlay({
        color: nativeTheme.shouldUseDarkColors ? '#1a1a1a' : '#f9f9f9',
        symbolColor: nativeTheme.shouldUseDarkColors ? '#f3f4f6' : '#000000',
        height: 48
      });

      return { success: true, theme };
    } catch (error) {
      console.error('è®¾ç½®ä¸»é¢˜å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });
  
  // æ·»åŠ : è·å–å½“å‰ä¸»é¢˜è®¾ç½®
  ipcMain.handle('get-theme', () => {
    try {
      // ä»é…ç½®æ–‡ä»¶è¯»å–ä¸»é¢˜è®¾ç½?      const themeConfigPath = path.join(userDataPath, 'theme-config.json');
      if (fs.existsSync(themeConfigPath)) {
        const themeConfig = JSON.parse(fs.readFileSync(themeConfigPath, 'utf8'));
        return { success: true, theme: themeConfig.theme || 'system' };
      }
      
      // é»˜è®¤è¿”å›ç³»ç»Ÿè®¾ç½®
      return { success: true, theme: 'system' };
    } catch (error) {
      console.error('è·å–ä¸»é¢˜è®¾ç½®å¤±è´¥:', error);
      return { success: false, theme: 'system', error: error.message };
    }
  });

  ipcMain.handle('save-subscription', (event, subUrl, configData, customName) => {
    // æ·»åŠ è°ƒè¯•è¾“å‡º
    console.log('ä¿å­˜è®¢é˜… - URL:', subUrl);
    console.log('ä¿å­˜è®¢é˜… - è‡ªå®šä¹‰åç§?', customName);
    
    // å¦‚æœæä¾›äº†è‡ªå®šä¹‰åç§°ï¼Œä½¿ç”¨å®ƒä½œä¸ºæ–‡ä»¶åï¼Œå¦åˆ™ä½¿ç”¨æ—¶é—´æˆ?    const fileName = customName 
      ? `${customName.replace(/[^\w\u4e00-\u9fa5\-\.]/g, '_')}.yaml` // æ›¿æ¢éæ³•å­—ç¬¦
      : `sub_${Date.now()}.yaml`;
    
    console.log('ä¿å­˜è®¢é˜… - æœ€ç»ˆæ–‡ä»¶å:', fileName);
    
    const filePath = path.join(configDir, fileName);
    fs.writeFileSync(filePath, configData);
    
    // ä¿å­˜è®¢é˜…URLåˆ°è®°å½•æ–‡ä»?    try {
      // è¯»å–è®¢é˜…URLè®°å½•æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      const urlsPath = path.join(configDir, 'subscription_urls.json');
      let urlsData = {};
      if (fs.existsSync(urlsPath)) {
        urlsData = JSON.parse(fs.readFileSync(urlsPath, 'utf8'));
      }
      
      // æ›´æ–°URLè®°å½•
      urlsData[fileName] = subUrl;
      
      // ä¿å­˜æ›´æ–°åçš„è®°å½•
      fs.writeFileSync(urlsPath, JSON.stringify(urlsData, null, 2), 'utf8');
      console.log(`è®¢é˜…URLå·²è®°å½? ${fileName} -> ${subUrl}`);
    } catch (error) {
      console.warn('ä¿å­˜è®¢é˜…URLè®°å½•å¤±è´¥:', error);
    }
    
    return filePath;
  });

  ipcMain.handle('get-subscriptions', () => {
    if (!fs.existsSync(configDir)) return [];
    
    return fs.readdirSync(configDir)
      .filter(file => file.endsWith('.yaml'))
      .map(file => ({
        name: file.replace('.yaml', ''),
        path: path.join(configDir, file)
      }));
  });

  ipcMain.handle('delete-subscription', (event, filePath) => {
    try {
      fs.unlinkSync(filePath);
      return true;
    } catch (error) {
      console.error(`Failed to delete ${filePath}:`, error);
      return false;
    }
  });

  ipcMain.handle('get-traffic-stats', () => {
    return lastTrafficStats;
  });

  // æ–°å¢ï¼šä»ä¸»è¿›ç¨‹è·å–è®¢é˜…å†…å®?  ipcMain.handle('fetch-subscription', async (event, subUrl) => {
    try {
      const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
      
      // ç¡®ä¿è®¢é˜…URLæœ‰æ•ˆ
      if (!subUrl || !subUrl.startsWith('http')) {
        throw new Error('æ— æ•ˆçš„è®¢é˜…URL');
      }
      
      console.log('æ­£åœ¨è·å–è®¢é˜…å†…å®¹...');
      const response = await fetch(subUrl);
      
      if (!response.ok) {
        throw new Error(`è·å–è®¢é˜…å¤±è´¥: ${response.statusText}`);
      }
      
      const content = await response.text();
      
      if (!content || content.trim() === '') {
        throw new Error('è®¢é˜…å†…å®¹ä¸ºç©º');
      }
      
      // æ£€æŸ¥è·å–çš„å†…å®¹æ˜¯å¦æ˜¯æœ‰æ•ˆçš„YAMLæˆ–JSON
      try {
        yaml.load(content);
      } catch (yamlError) {
        try {
          JSON.parse(content);
        } catch (jsonError) {
          throw new Error('è®¢é˜…å†…å®¹æ ¼å¼æ— æ•ˆï¼Œä¸æ˜¯æœ‰æ•ˆçš„YAMLæˆ–JSON');
        }
      }
      
      console.log('è®¢é˜…å†…å®¹è·å–æˆåŠŸ');
      return content;
    } catch (error) {
      console.error('è·å–è®¢é˜…å¤±è´¥:', error);
      return null;
    }
  });

  ipcMain.handle('open-external', (event, url) => {
    shell.openExternal(url);
    return { success: true };
  });

  // æ–°å¢ï¼šæ‰“å¼€æ–‡ä»¶
  ipcMain.handle('open-file', (event, filePath) => {
    try {
      // åœ¨Windowsä¸Šï¼Œä½¿ç”¨shell.openPathæ‰“å¼€æ–‡ä»¶
      shell.openPath(filePath);
      return { success: true };
    } catch (error) {
      console.error('æ‰“å¼€æ–‡ä»¶å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  // æ–°å¢ï¼šæ‰“å¼€æ–‡ä»¶æ‰€åœ¨ç›®å½?  ipcMain.handle('open-file-location', (event, filePath) => {
    try {
      // åœ¨Windowsä¸Šï¼Œä½¿ç”¨shell.showItemInFolderæ‰“å¼€æ–‡ä»¶æ‰€åœ¨ç›®å½?      shell.showItemInFolder(filePath);
      return { success: true };
    } catch (error) {
      console.error('æ‰“å¼€æ–‡ä»¶æ‰€åœ¨ç›®å½•å¤±è´?', error);
      return { success: false, error: error.message };
    }
  });

  // æ–°å¢ï¼šæ›´æ–°æŒ‡å®šçš„è®¢é˜…
  ipcMain.handle('refresh-subscription', async (event, filePath) => {
    try {
      // è·å–è®¢é˜…URL
      // ç›´æ¥è°ƒç”¨get-subscription-urlå¤„ç†ç¨‹åºå‡½æ•°
      const getSubscriptionUrlHandler = async (filePath) => {
        try {
          // è·å–æ–‡ä»¶å?          const fileName = path.basename(filePath);
          
          // è¯»å–è®¢é˜…URLè®°å½•
          const urlsPath = path.join(configDir, 'subscription_urls.json');
          if (!fs.existsSync(urlsPath)) {
            console.log('è®¢é˜…URLè®°å½•æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå°è¯•åˆ›å»ºæ–°è®°å½?);
            
            // åˆ›å»ºä¸€ä¸ªç©ºçš„è®°å½•æ–‡ä»?            fs.writeFileSync(urlsPath, JSON.stringify({}, null, 2), 'utf8');
            
            // å¯¹äºæ—§ç‰ˆæœ¬æ·»åŠ çš„è®¢é˜…ï¼Œæˆ‘ä»¬å¯ä»¥æç¤ºç”¨æˆ·é‡æ–°æ·»åŠ?            return { success: false, error: 'æœªæ‰¾åˆ°è®¢é˜…URLè®°å½•ã€‚è¿™å¯èƒ½æ˜¯å› ä¸ºæ­¤è®¢é˜…æ˜¯åœ¨æ—§ç‰ˆæœ¬æ·»åŠ çš„ï¼Œè¯·å°è¯•åˆ é™¤å¹¶é‡æ–°æ·»åŠ è®¢é˜…ã€? };
          }
          
          // è§£æè®°å½•æ–‡ä»¶
          const urlsData = JSON.parse(fs.readFileSync(urlsPath, 'utf8'));
          
          // é¦–å…ˆå°è¯•ä½¿ç”¨å®Œæ•´æ–‡ä»¶åæŸ¥æ‰?          let url = urlsData[fileName];
          
          // å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°è¯•åªä½¿ç”¨æ–‡ä»¶åéƒ¨åˆ†ï¼ˆä¸åŒ…å«è·¯å¾„ï¼?          if (!url) {
            const fileNameOnly = fileName.replace(/\.yaml$/, '');
            for (const [key, value] of Object.entries(urlsData)) {
              const keyWithoutExt = key.replace(/\.yaml$/, '');
              if (keyWithoutExt === fileNameOnly) {
                url = value;
                
                // æ›´æ–°è®°å½•ä»¥ä½¿ç”¨æ­£ç¡®çš„æ–‡ä»¶å?                urlsData[fileName] = value;
                fs.writeFileSync(urlsPath, JSON.stringify(urlsData, null, 2), 'utf8');
                break;
              }
            }
          }
          
          if (!url) {
            console.log(`æœªæ‰¾åˆ°æ–‡ä»?${fileName} å¯¹åº”çš„è®¢é˜…URL`);
            return { success: false, error: 'æœªæ‰¾åˆ°å¯¹åº”çš„è®¢é˜…URLã€‚è¯·å°è¯•åˆ é™¤å¹¶é‡æ–°æ·»åŠ è®¢é˜…ã€? };
          }
          
          console.log(`æ‰¾åˆ°æ–‡ä»¶ ${fileName} å¯¹åº”çš„è®¢é˜…URL: ${url}`);
          return { success: true, url };
        } catch (error) {
          console.error('è·å–è®¢é˜…URLå¤±è´¥:', error);
          return { success: false, error: error.message };
        }
      };
      
      const urlResult = await getSubscriptionUrlHandler(filePath);
      
      if (!urlResult.success || !urlResult.url) {
        return { success: false, error: urlResult.error || 'æ— æ³•è·å–è®¢é˜…URL' };
      }
      
      const subUrl = urlResult.url;
      console.log(`å‡†å¤‡åˆ·æ–°è®¢é˜…: ${filePath}, URL: ${subUrl}`);
      
      // è·å–è®¢é˜…å†…å®¹
      const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
      
      // ç¡®ä¿è®¢é˜…URLæœ‰æ•ˆ
      if (!subUrl || !subUrl.startsWith('http')) {
        throw new Error('æ— æ•ˆçš„è®¢é˜…URL');
      }
      
      console.log('æ­£åœ¨è·å–è®¢é˜…å†…å®¹...');
      const response = await fetch(subUrl, {
        headers: {
          'User-Agent': `FlyClash/${APP_VERSION}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`è·å–è®¢é˜…å¤±è´¥: ${response.statusText}`);
      }
      
      const configData = await response.text();
      
      if (!configData || configData.trim() === '') {
        throw new Error('è®¢é˜…å†…å®¹ä¸ºç©º');
      }
      
      // æ£€æŸ¥è·å–çš„å†…å®¹æ˜¯å¦æ˜¯æœ‰æ•ˆçš„YAMLæˆ–JSON
      try {
        yaml.load(configData);
      } catch (yamlError) {
        try {
          JSON.parse(configData);
        } catch (jsonError) {
          throw new Error('è®¢é˜…å†…å®¹æ ¼å¼æ— æ•ˆï¼Œä¸æ˜¯æœ‰æ•ˆçš„YAMLæˆ–JSON');
        }
      }
      
      // ç›´æ¥å®ç°æ›´æ–°è®¢é˜…æ–‡ä»¶çš„åŠŸèƒ½ï¼Œè€Œä¸æ˜¯è°ƒç”¨updateSubscription
      try {
        // ç¡®ä¿æ–‡ä»¶è·¯å¾„å’Œé…ç½®æ•°æ®æœ‰æ•?        if (!filePath || !configData) {
          throw new Error('æ— æ•ˆçš„æ–‡ä»¶è·¯å¾„æˆ–é…ç½®æ•°æ®');
        }
        
        console.log('æ­£åœ¨æ›´æ–°è®¢é˜…æ–‡ä»¶:', filePath);
        
        // å¤‡ä»½åŸå§‹æ–‡ä»¶
        const backupPath = `${filePath}.bak`;
        if (fs.existsSync(filePath)) {
          fs.copyFileSync(filePath, backupPath);
        }
        
        // å†™å…¥æ–°çš„é…ç½®å†…å®¹
        fs.writeFileSync(filePath, configData, 'utf8');
        
        // æ›´æ–°è®¢é˜…URLçš„è®°å½•ï¼ˆå¦‚æœæœ‰è®°å½•ç³»ç»Ÿï¼‰
        if (subUrl) {
          try {
            // è¯»å–è®¢é˜…URLè®°å½•æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const urlsPath = path.join(configDir, 'subscription_urls.json');
            let urlsData = {};
            if (fs.existsSync(urlsPath)) {
              urlsData = JSON.parse(fs.readFileSync(urlsPath, 'utf8'));
            }
            
            // æ›´æ–°URLè®°å½•
            urlsData[path.basename(filePath)] = subUrl;
            
            // ä¿å­˜æ›´æ–°åçš„è®°å½•
            fs.writeFileSync(urlsPath, JSON.stringify(urlsData, null, 2), 'utf8');
          } catch (error) {
            console.warn('æ›´æ–°è®¢é˜…URLè®°å½•å¤±è´¥ï¼Œä½†é…ç½®æ–‡ä»¶å·²æ›´æ–?', error);
          }
        }
        
        console.log('è®¢é˜…æ›´æ–°æˆåŠŸ');
        return { success: true, filePath };
      } catch (error) {
        console.error('æ›´æ–°è®¢é˜…å¤±è´¥:', error);
        // å¦‚æœæœ‰å¤‡ä»½ï¼Œå°è¯•æ¢å¤
        const backupPath = `${filePath}.bak`;
        if (fs.existsSync(backupPath)) {
          try {
            fs.copyFileSync(backupPath, filePath);
            console.log('å·²ä»å¤‡ä»½æ¢å¤åŸå§‹æ–‡ä»¶');
          } catch (restoreError) {
            console.error('ä»å¤‡ä»½æ¢å¤å¤±è´?', restoreError);
          }
        }
        return { success: false, error: error.message };
      }
    } catch (error) {
      console.error('åˆ·æ–°è®¢é˜…å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  // åˆ‡æ¢èŠ‚ç‚¹
  ipcMain.handle('select-node', async (event, nodeName, groupName, updateGlobal = false) => {
    try {
      console.log(`åˆ‡æ¢èŠ‚ç‚¹: ${nodeName} åœ¨ç»„ ${groupName}`);
      
      if (!groupName) {
        groupName = 'PROXY'; // é»˜è®¤ä½¿ç”¨PROXYç»?      }
      
      // åˆ‡æ¢æŒ‡å®šç»„çš„èŠ‚ç‚¹
      const response = await fetch(`http://127.0.0.1:9090/proxies/${encodeURIComponent(groupName)}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ name: nodeName })
      });

      if (!response.ok) {
        throw new Error(`åˆ‡æ¢èŠ‚ç‚¹å¤±è´¥: ${response.statusText}`);
      }
      
      console.log(`æˆåŠŸåˆ‡æ¢åˆ°èŠ‚ç‚? ${nodeName} åœ¨ç»„ ${groupName}`);
      
      // å¦‚æœæ˜¯PROXYæˆ–GLOBALç»„ï¼Œæˆ–è€…è¦æ±‚æ›´æ–°å…¨å±€èŠ‚ç‚¹ï¼Œæ›´æ–°å½“å‰èŠ‚ç‚¹å˜é‡?      if (groupName === 'PROXY' || groupName === 'GLOBAL' || updateGlobal) {
        currentNode = nodeName;
        console.log('æ›´æ–°å½“å‰èŠ‚ç‚¹:', currentNode);
        
        // æ›´æ–°æ‰˜ç›˜èœå•
        updateTrayMenu();
      }
      
      return { success: true };
    } catch (error) {
      console.error('é€‰æ‹©èŠ‚ç‚¹å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  // æ–°å¢ï¼šæ¥æ”¶èŠ‚ç‚¹å˜æ›´é€šçŸ¥
  ipcMain.handle('notify-node-changed', async (event, nodeName) => {
    try {
      console.log(`æ¥æ”¶åˆ°èŠ‚ç‚¹å˜æ›´é€šçŸ¥: ${nodeName}`);
      
      // æ›´æ–°å½“å‰èŠ‚ç‚¹
      currentNode = nodeName;
      
      // æ›´æ–°æ‰˜ç›˜èœå•ä»¥åæ˜ æ–°èŠ‚ç‚¹
      updateTrayMenu();
      
      return { success: true };
    } catch (error) {
      console.error('å¤„ç†èŠ‚ç‚¹å˜æ›´é€šçŸ¥å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  // æ–°å¢ï¼šè·å–ä»£ç†èŠ‚ç‚¹ä¿¡æ?  ipcMain.handle('get-proxies', async (event) => {
    try {
      console.log(`[DEBUG] å¼€å§‹è·å–ä»£ç†èŠ‚ç‚¹ä¿¡æ¯`);
      
      // æ£€æŸ¥MihomoæœåŠ¡çŠ¶æ€?      const isServiceRunning = await checkMihomoService();
      if (!isServiceRunning) {
        console.error('[DEBUG] MihomoæœåŠ¡æœªè¿è¡?);
        throw new Error('MihomoæœåŠ¡æœªè¿è¡Œï¼Œè¯·å…ˆå¯åŠ¨Mihomo');
      }
      
      // ä½¿ç”¨fetch APIè·å–ä»£ç†èŠ‚ç‚¹ä¿¡æ¯
      const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
      
      // è·å–ä»£ç†èŠ‚ç‚¹ä¿¡æ¯
      const response = await fetch('http://127.0.0.1:9090/proxies');
      const data = await response.json();
      
      console.log(`[DEBUG] è·å–ä»£ç†èŠ‚ç‚¹ä¿¡æ¯æˆåŠŸ`);
      
      // å¤„ç†æ•°æ®ï¼Œæå–èŠ‚ç‚¹ç»„å’Œå½“å‰é€‰ä¸­çš„èŠ‚ç‚?      const groups = [];
      let selected = null;
      
      // é¦–å…ˆæŸ¥æ‰¾PROXYç»?      if (data.proxies && data.proxies['PROXY']) {
        const proxyGroup = data.proxies['PROXY'];
        selected = proxyGroup.now;
        
        // æå–èŠ‚ç‚¹ç»?        if (proxyGroup.all && proxyGroup.all.length > 0) {
          const nodes = [];
          for (const nodeName of proxyGroup.all) {
            if (data.proxies[nodeName]) {
              const node = data.proxies[nodeName];
              nodes.push({
                name: nodeName,
                type: node.type,
                server: node.server || '',
                port: node.port || 0,
                delay: node.delay || undefined
              });
            }
          }
          
          groups.push({
            name: 'PROXY',
            type: proxyGroup.type,
            nodes: nodes
          });
        }
      }
      // å¦‚æœPROXYç»„ä¸å­˜åœ¨ï¼Œåˆ™æŸ¥æ‰¾GLOBALç»„ä½œä¸ºå¤‡é€?      else if (data.proxies && data.proxies['GLOBAL']) {
        const globalGroup = data.proxies['GLOBAL'];
        selected = globalGroup.now;
        
        // æå–èŠ‚ç‚¹ç»?        if (globalGroup.all && globalGroup.all.length > 0) {
          const nodes = [];
          for (const nodeName of globalGroup.all) {
            if (data.proxies[nodeName]) {
              const node = data.proxies[nodeName];
              nodes.push({
                name: nodeName,
                type: node.type,
                server: node.server || '',
                port: node.port || 0,
                delay: node.delay || undefined
              });
            }
          }
          
          groups.push({
            name: 'GLOBAL',
            type: globalGroup.type,
            nodes: nodes
          });
        }
      }
      
      // æå–å…¶ä»–èŠ‚ç‚¹ç»?      for (const [name, proxy] of Object.entries(data.proxies)) {
        if (proxy.type === 'Selector' || proxy.type === 'URLTest' || proxy.type === 'Fallback' || proxy.type === 'LoadBalance') {
          if (name !== 'GLOBAL' && name !== 'PROXY' && proxy.all && proxy.all.length > 0) {
            const nodes = [];
            for (const nodeName of proxy.all) {
              if (data.proxies[nodeName]) {
                const node = data.proxies[nodeName];
                nodes.push({
                  name: nodeName,
                  type: node.type,
                  server: node.server || '',
                  port: node.port || 0,
                  delay: node.delay || undefined
                });
              }
            }
            
            groups.push({
              name: name,
              type: proxy.type,
              nodes: nodes
            });
          }
        }
      }
      
      return {
        groups: groups,
        selected: selected
      };
    } catch (error) {
      console.error(`[DEBUG] è·å–ä»£ç†èŠ‚ç‚¹ä¿¡æ¯å¤±è´¥:`, error);
      return { groups: [], selected: null };
    }
  });

  // æµ‹è¯•èŠ‚ç‚¹å»¶è¿Ÿ
  ipcMain.handle('test-node-delay', async (event, nodeName) => {
    try {
      console.log(`[DEBUG] å¼€å§‹æµ‹è¯•èŠ‚ç‚¹å»¶è¿? ${nodeName}`);
      
      // æ£€æŸ¥MihomoæœåŠ¡çŠ¶æ€?      const isServiceRunning = await checkMihomoService();
      if (!isServiceRunning) {
        console.error('[DEBUG] MihomoæœåŠ¡æœªè¿è¡Œï¼Œæ— æ³•æµ‹è¯•èŠ‚ç‚¹å»¶è¿Ÿ');
        throw new Error('MihomoæœåŠ¡æœªè¿è¡Œï¼Œæ— æ³•æµ‹è¯•èŠ‚ç‚¹å»¶è¿Ÿ');
      }
      
      // ä½¿ç”¨fetch APIæµ‹è¯•èŠ‚ç‚¹å»¶è¿Ÿ
          const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
      
      // è®¾ç½®URLå’Œå‚æ•?      const url = new URL(`http://127.0.0.1:9090/proxies/${encodeURIComponent(nodeName)}/delay`);
      url.searchParams.append('url', 'http://www.gstatic.com/generate_204');
      url.searchParams.append('timeout', '5000');
      
      // å‘é€è¯·æ±?      console.log(`[DEBUG] å‘é€æµ‹è¯•å»¶è¿Ÿè¯·æ±? ${url.toString()}`);
      const response = await fetch(url.toString());
      
      // å¤„ç†å“åº”
          if (response.ok) {
            const data = await response.json();
        console.log(`[DEBUG] èŠ‚ç‚¹ ${nodeName} å»¶è¿Ÿæµ‹è¯•ç»“æœ: ${data.delay}ms`);
        
        // è¿”å›å»¶è¿Ÿç»“æœ - 0msè¡¨ç¤ºè¶…æ—¶æˆ–ä¸å¯ç”¨ï¼Œæ‰€ä»¥ç›´æ¥è¿”å›?
        return data.delay;
          } else {
        const errorText = await response.text();
        console.error(`[DEBUG] æµ‹è¯•èŠ‚ç‚¹å»¶è¿Ÿå¤±è´¥: ${response.status} ${response.statusText} - ${errorText}`);
        
        // APIè°ƒç”¨å¤±è´¥ä¹Ÿè¡¨ç¤ºä¸å¯ç”¨ï¼Œè¿”å›?
        return 0;
          }
        } catch (error) {
      console.error(`[DEBUG] æµ‹è¯•èŠ‚ç‚¹å»¶è¿Ÿè¿‡ç¨‹ä¸­å‡ºé”?`, error);
      
      // è¿”å›0è¡¨ç¤ºæµ‹è¯•å¤±è´¥/è¶…æ—¶
      return 0;
    }
  });

  ipcMain.handle('get-active-config', () => {
    // é€šè¿‡configFilePathåˆ¤æ–­mihomoæ˜¯å¦åœ¨è¿è¡?    // å¦‚æœmihomoå·²åœæ­¢ï¼Œè¿™é‡Œåº”è¯¥è¿”å›null
    return configFilePath || null;
  });
  
  ipcMain.handle('get-proxy-nodes', (event, configPath) => {
    try {
      // å¦‚æœæŒ‡å®šäº†é…ç½®è·¯å¾„ï¼Œåˆ™ä½¿ç”¨æŒ‡å®šçš„è·¯å¾„
      // å¦åˆ™ä½¿ç”¨å½“å‰æ¿€æ´»çš„é…ç½®
      const config = configPath || configFilePath;
      if (!config) {
        return null;
      }
      
      return parseConfigFile(config);
    } catch (error) {
      console.error('è·å–ä»£ç†èŠ‚ç‚¹å¤±è´¥:', error);
      return null;
    }
  });
  
  // å¤„ç†è·å–åº”ç”¨ç‰ˆæœ¬å?  ipcMain.handle('get-app-version', () => {
    return APP_VERSION;
  });

  // å¤„ç†è‡ªåŠ¨å¯åŠ¨è®¾ç½®
  ipcMain.handle('set-auto-start', (event, enabled) => {
    autoStartEnabled = enabled;
    return true;
  });
  
  // è·å–è‡ªåŠ¨å¯åŠ¨è®¾ç½®
  ipcMain.handle('get-auto-start', () => {
    return autoStartEnabled;
  });
  
  // èŠ‚ç‚¹æ”¶è—ç®¡ç†
  ipcMain.handle('get-favorite-nodes', () => {
    try {
      const favoritesPath = path.join(userDataPath, 'favorites.json');
      if (!fs.existsSync(favoritesPath)) {
        console.log('æ”¶è—èŠ‚ç‚¹æ–‡ä»¶ä¸å­˜åœ?);
        return { success: true, nodes: [] };
      }
      
      const favoritesData = JSON.parse(fs.readFileSync(favoritesPath, 'utf8'));
      console.log('æˆåŠŸåŠ è½½æ”¶è—èŠ‚ç‚¹:', favoritesData);
      return { success: true, nodes: favoritesData };
    } catch (error) {
      console.error('è·å–æ”¶è—èŠ‚ç‚¹å¤±è´¥:', error);
      return { success: false, nodes: [], error: error.message };
    }
  });
  
  ipcMain.handle('save-favorite-nodes', (event, nodes) => {
    try {
      if (!Array.isArray(nodes)) {
        throw new Error('æ— æ•ˆçš„èŠ‚ç‚¹æ•°æ®æ ¼å¼?);
      }
      
      const favoritesPath = path.join(userDataPath, 'favorites.json');
      fs.writeFileSync(favoritesPath, JSON.stringify(nodes), 'utf8');
      console.log('æ”¶è—èŠ‚ç‚¹ä¿å­˜æˆåŠŸ:', nodes);
      return { success: true };
    } catch (error) {
      console.error('ä¿å­˜æ”¶è—èŠ‚ç‚¹å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });
  
  // èŠ‚ç‚¹ç»„æŠ˜å ç®¡ç?  ipcMain.handle('get-collapsed-groups', () => {
    try {
      const collapsedPath = path.join(userDataPath, 'collapsed-groups.json');
      if (!fs.existsSync(collapsedPath)) {
        console.log('æŠ˜å ç»„æ–‡ä»¶ä¸å­˜åœ¨');
        return { success: true, groups: [] };
      }
      
      const collapsedData = JSON.parse(fs.readFileSync(collapsedPath, 'utf8'));
      console.log('æˆåŠŸåŠ è½½æŠ˜å ç»?', collapsedData);
      return { success: true, groups: collapsedData };
    } catch (error) {
      console.error('è·å–æŠ˜å ç»„å¤±è´?', error);
      return { success: false, groups: [], error: error.message };
    }
  });
  
  ipcMain.handle('save-collapsed-groups', (event, groups) => {
    try {
      if (!Array.isArray(groups)) {
        throw new Error('æ— æ•ˆçš„ç»„æ•°æ®æ ¼å¼');
      }
      
      const collapsedPath = path.join(userDataPath, 'collapsed-groups.json');
      fs.writeFileSync(collapsedPath, JSON.stringify(groups), 'utf8');
      console.log('æŠ˜å ç»„ä¿å­˜æˆåŠ?', groups);
      return { success: true };
    } catch (error) {
      console.error('ä¿å­˜æŠ˜å ç»„å¤±è´?', error);
      return { success: false, error: error.message };
    }
  });
  
  // ä¿å­˜æ—¥å¿—åˆ°æ–‡ä»?  ipcMain.handle('save-logs', (event, logEntries) => {
    try {
      const logsDir = path.join(userDataPath, 'logs');
      if (!fs.existsSync(logsDir)) {
        fs.mkdirSync(logsDir, { recursive: true });
      }
      
      const date = new Date();
      const fileName = `mihomo-logs-${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}-${String(date.getHours()).padStart(2, '0')}-${String(date.getMinutes()).padStart(2, '0')}.txt`;
      const filePath = path.join(logsDir, fileName);
      
      // æ ¼å¼åŒ–æ—¥å¿—å†…å®?      const logContent = logEntries.map(entry => {
        const timestamp = new Date(entry.timestamp).toLocaleString();
        const type = entry.type === 'error' ? '[é”™è¯¯]' : '[ä¿¡æ¯]';
        return `${timestamp} ${type} ${entry.content}`;
      }).join('\n');
      
      fs.writeFileSync(filePath, logContent, 'utf8');
      console.log(`æ—¥å¿—å·²ä¿å­˜åˆ°: ${filePath}`);
      
      return { success: true, filePath };
    } catch (error) {
      console.error('ä¿å­˜æ—¥å¿—å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  // æ–°å¢: åˆ‡æ¢ç³»ç»Ÿä»£ç†
  ipcMain.handle('toggleSystemProxy', async (event, enabled) => {
    try {
      // åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„èœå•é¡¹å¯¹è±?      const menuItem = { checked: enabled };
      
      // è°ƒç”¨ç°æœ‰çš„toggleSystemProxyå‡½æ•°
      toggleSystemProxy(menuItem);
      
      // è¿”å›å½“å‰çš„ç³»ç»Ÿä»£ç†çŠ¶æ€?      return systemProxyEnabled;
    } catch (error) {
      console.error('åˆ‡æ¢ç³»ç»Ÿä»£ç†å¤±è´¥:', error);
      return false;
    }
  });

  // æ–°å¢: è·å–ç³»ç»Ÿä»£ç†çŠ¶æ€?  ipcMain.handle('getProxyStatus', async () => {
    return systemProxyEnabled;
  });

  // æ·»åŠ è·å–è¿æ¥ä¿¡æ¯çš„å‡½æ•?  ipcMain.handle('get-connections', async () => {
    try {
      const response = await fetch('http://127.0.0.1:9090/connections');
      if (response.ok) {
        const data = await response.json();
        console.log('è·å–åˆ°è¿æ¥ä¿¡æ?', data); // æ·»åŠ æ—¥å¿—
        return data;
      } else {
        console.error('è·å–è¿æ¥ä¿¡æ¯å¤±è´¥:', response.status, response.statusText);
        return null;
      }
    } catch (error) {
      console.error('è·å–è¿æ¥ä¿¡æ¯å¤±è´¥:', error);
      return null;
    }
  });

  // æ·»åŠ å…³é—­ç‰¹å®šè¿æ¥çš„å‡½æ•?  ipcMain.handle('close-connection', async (event, connectionId) => {
    try {
      console.log(`å°è¯•å…³é—­è¿æ¥: ${connectionId}`); // æ·»åŠ æ—¥å¿—
      const response = await fetch(`http://127.0.0.1:9090/connections/${connectionId}`, {
        method: 'DELETE'
      });
      const success = response.ok;
      console.log(`å…³é—­è¿æ¥ç»“æœ: ${success ? 'æˆåŠŸ' : 'å¤±è´¥'}`); // æ·»åŠ æ—¥å¿—
      return success;
    } catch (error) {
      console.error('å…³é—­è¿æ¥å¤±è´¥:', error);
      return false;
    }
  });

  // æ·»åŠ å…³é—­æ‰€æœ‰è¿æ¥çš„å‡½æ•°
  ipcMain.handle('close-all-connections', async () => {
    try {
      console.log('å°è¯•å…³é—­æ‰€æœ‰è¿æ?); // æ·»åŠ æ—¥å¿—
      const response = await fetch('http://127.0.0.1:9090/connections', {
        method: 'DELETE'
      });
      const success = response.ok;
      console.log(`å…³é—­æ‰€æœ‰è¿æ¥ç»“æ? ${success ? 'æˆåŠŸ' : 'å¤±è´¥'}`); // æ·»åŠ æ—¥å¿—
      return success;
    } catch (error) {
      console.error('å…³é—­æ‰€æœ‰è¿æ¥å¤±è´?', error);
      return false;
    }
  });

  // å¤„ç†è¿æ¥ä¿¡æ¯æ›´æ–°
  ipcMain.on('connections-update', (event, data) => {
    if (mainWindow) {
      console.log('ä¸»è¿›ç¨‹å‘é€è¿æ¥ä¿¡æ¯æ›´æ–?', data);
      mainWindow.webContents.send('connections-update', {
        connections: data.connections || [],
        downloadTotal: data.downloadTotal || 0,
        uploadTotal: data.uploadTotal || 0,
        currentNode: currentNode,
        activeConnections: data.connections ? data.connections.filter(conn => conn.isActive).length : 0
      });
    }
  });

  // å¤„ç†èŠ‚ç‚¹å˜æ›´
  ipcMain.on('node-changed', (event, data) => {
    if (mainWindow) {
      console.log('ä¸»è¿›ç¨‹å‘é€èŠ‚ç‚¹å˜æ›?', data);
      // æ›´æ–°å½“å‰èŠ‚ç‚¹
      if (data && data.nodeName) {
        currentNode = data.nodeName;
      }
      
      mainWindow.webContents.send('node-changed', {
        nodeName: data && data.nodeName ? data.nodeName : (currentNode || 'æ—?)
      });
      
      // åŒæ—¶æ›´æ–°è¿æ¥ä¿¡æ¯
      const connectionInfo = {
        ...lastConnectionsInfo,
        currentNode: currentNode
      };
      mainWindow.webContents.send('connections-update', connectionInfo);
    }
  });

  // æ–°å¢ï¼šè·å–æ€»è¿æ¥ä¿¡æ¯å’Œæ€»æµé‡?  ipcMain.handle('fetch-connections-info', async () => {
    return fetchConnectionsInfo();
  });

  // æ·»åŠ APIä¿å­˜æœ€åä¸€æ¬¡ä½¿ç”¨çš„é…ç½®æ–‡ä»¶
  ipcMain.handle('save-last-config', (event, configPath) => {
    try {
      if (!configPath) {
        console.log('æ— æ•ˆçš„é…ç½®è·¯å¾„ï¼Œæ— æ³•ä¿å­˜');
        return { success: false, error: 'æ— æ•ˆçš„é…ç½®è·¯å¾? };
      }
      
      // ä¿å­˜é…ç½®è·¯å¾„åˆ°ç”¨æˆ·æ•°æ®ç›®å½?      const lastConfigPath = path.join(userDataPath, 'last-config.json');
      fs.writeFileSync(lastConfigPath, JSON.stringify({ path: configPath }, null, 2), 'utf8');
      console.log('å·²ä¿å­˜æœ€åä½¿ç”¨çš„é…ç½®æ–‡ä»¶:', configPath);
      
      return { success: true };
    } catch (error) {
      console.error('ä¿å­˜æœ€åä½¿ç”¨çš„é…ç½®æ–‡ä»¶å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  // æ·»åŠ é‡å¯MihomoæœåŠ¡çš„å‡½æ•°ï¼ˆç”¨äºé…ç½®ä¿®æ”¹åï¼‰
  ipcMain.handle('restart-service', async () => {
    try {
      // ä¿å­˜å½“å‰çš„é…ç½®è·¯å¾?      const currentConfig = configFilePath;
      
      // å…ˆåœæ­¢æœåŠ?      if (mihomoProcess) {
        mihomoProcess.kill();
        mihomoProcess = null;
        stopTrafficStatsUpdate();
        stopConnectionsWebSocket();
        
        // ç­‰å¾…è¿›ç¨‹å®Œå…¨å…³é—­
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      // ç„¶åä½¿ç”¨ç›¸åŒçš„é…ç½®é‡å?      if (currentConfig) {
        const success = await startMihomo(currentConfig);
        return { success, message: success ? 'æœåŠ¡å·²é‡å? : 'é‡å¯å¤±è´¥' };
      } else {
        return { success: false, message: 'æ²¡æœ‰æ´»åŠ¨çš„é…ç½®æ–‡ä»? };
      }
    } catch (error) {
      console.error('é‡å¯æœåŠ¡å¤±è´¥:', error);
      return { success: false, message: `é‡å¯å¤±è´¥: ${error.message}` };
    }
  });

  // æ·»åŠ : å¯åŠ¨Mihomo
  ipcMain.handle('start-mihomo', async (event, configPath) => {
    try {
      if (!configPath) {
        console.error('å¯åŠ¨Mihomoå¤±è´¥: æœªæä¾›é…ç½®è·¯å¾?);
        return false;
      }
      return await startMihomo(configPath);
    } catch (error) {
      console.error('å¯åŠ¨Mihomoå¤„ç†ç¨‹åºå‡ºé”™:', error);
      return false;
    }
  });

  // æ·»åŠ : åœæ­¢Mihomo
  ipcMain.handle('stop-mihomo', async () => {
    try {
      if (mihomoProcess) {
        mihomoProcess.kill();
        mihomoProcess = null;
        stopTrafficStatsUpdate();
        stopConnectionsWebSocket();
        // æ¸…é™¤configFilePathï¼Œè¿™æ ·get-active-configå°†è¿”å›null
        configFilePath = null;
        console.log('Mihomoå·²åœæ­?);
        return true;
      }
      return false;
    } catch (error) {
      console.error('åœæ­¢Mihomoå¤±è´¥:', error);
      return false;
    }
  });

  // è®¾ç½®å¼€æœºå¯åŠ?  ipcMain.handle('set-auto-launch', (event, enabled) => {
    setAutoLaunch(enabled);
    return true;
  });

  // è·å–å¼€æœºå¯åŠ¨çŠ¶æ€?  ipcMain.handle('get-auto-launch-state', () => {
    return getAutoLaunchState();
  });

  // è·å–ä»£ç†è®¾ç½®
  ipcMain.handle('get-proxy-settings', () => {
    try {
      const settings = getUserSettings();
      return { success: true, settings };
    } catch (error) {
      console.error('è·å–ä»£ç†è®¾ç½®å¤±è´¥:', error);
      return { success: false, error: error.message };
    }
  });

  // ä¿å­˜ä»£ç†è®¾ç½®
  ipcMain.handle('save-proxy-settings', (event, settings) => {
    try {
      console.log('æ­£åœ¨ä¿å­˜ä»£ç†è®¾ç½®:', settings);
      
      // éªŒè¯è®¾ç½®å¯¹è±¡
      if (!settings || typeof settings !== 'object') {
        console.error('æ¥æ”¶åˆ°æ— æ•ˆçš„è®¾ç½®å¯¹è±¡');
        return { 
          success: false, 
          error: 'æ— æ•ˆçš„è®¾ç½®å¯¹è±? 
        };
      }
      
      // éªŒè¯è®¾ç½®å­—æ®µ
      if ('mixed-port' in settings) {
        if (typeof settings['mixed-port'] !== 'number') {
          console.error('ç«¯å£å­—æ®µä¸æ˜¯æ•°å­—:', settings['mixed-port']);
          return { 
            success: false, 
            error: 'ç«¯å£å·å¿…é¡»æ˜¯æ•°å­—' 
          };
        }
        
        if (settings['mixed-port'] < 1 || settings['mixed-port'] > 65535) {
          console.error('ç«¯å£å·è¶…å‡ºèŒƒå›?', settings['mixed-port']);
          return { 
            success: false, 
            error: 'ç«¯å£å·æ— æ•ˆï¼Œå¿…é¡»æ˜?-65535ä¹‹é—´çš„æ•°å­? 
          };
        }
      }
      
      // æ›´æ–°è®¾ç½®
      console.log('éªŒè¯é€šè¿‡ï¼Œæ­£åœ¨æ›´æ–°ç”¨æˆ·è®¾ç½?);
      const success = updateUserSettings(settings);
      
      // è·å–å½“å‰é…ç½®è·¯å¾„
      const currentConfig = configFilePath;
      
      // å¦‚æœMihomoæ­£åœ¨è¿è¡Œï¼Œè¿›è¡Œå®Œå…¨é‡å?      if (success && mihomoProcess && mihomoProcess.pid && currentConfig) {
        console.log('Mihomoæ­£åœ¨è¿è¡Œï¼Œå°†é‡å¯æœåŠ¡åº”ç”¨æ–°è®¾ç½?);
        try {
          // åœæ­¢ç°æœ‰è¿›ç¨‹
          if (mihomoProcess) {
            mihomoProcess.kill();
            stopTrafficStatsUpdate();
            stopConnectionsWebSocket();
            // ç­‰å¾…è¿›ç¨‹å®Œå…¨ç»ˆæ­¢
            setTimeout(async () => {
              mihomoProcess = null;
              // é‡å¯Mihomo
              const restarted = await startMihomo(currentConfig);
              console.log('é‡å¯ç»“æœ:', restarted);
              
              if (restarted) {
                // é€šçŸ¥å‰ç«¯é‡å¯æˆåŠŸ
                if (mainWindow) {
                  mainWindow.webContents.send('service-restarted', { success: true });
                }
                console.log('æœåŠ¡å·²é‡å¯å¹¶åº”ç”¨æ–°è®¾ç½?);
              } else {
                // é€šçŸ¥å‰ç«¯é‡å¯å¤±è´¥
                if (mainWindow) {
                  mainWindow.webContents.send('service-restarted', { 
                    success: false, 
                    error: 'é‡å¯æœåŠ¡å¤±è´¥' 
                  });
                }
                console.error('é‡å¯æœåŠ¡å¤±è´¥');
              }
            }, 1000);
          }
          
          return { 
            success: true, 
            message: 'è®¾ç½®å·²ä¿å­˜ï¼Œæ­£åœ¨é‡å¯æœåŠ¡åº”ç”¨æ–°è®¾ç½?..' 
          };
        } catch (restartError) {
          console.error('é‡å¯æœåŠ¡è¿‡ç¨‹ä¸­å‡ºé”?', restartError);
          return { 
            success: true, 
            message: 'è®¾ç½®å·²ä¿å­˜ï¼Œä½†é‡å¯å¤±è´? ' + restartError.message
          };
        }
      }
      
      return { 
        success, 
        message: success ? 'è®¾ç½®å·²ä¿å­? : 'ä¿å­˜è®¾ç½®å¤±è´¥' 
      };
    } catch (error) {
      console.error('ä¿å­˜ä»£ç†è®¾ç½®å¤±è´¥:', error);
      return { 
        success: false, 
        error: `ä¿å­˜è®¾ç½®æ—¶å‘ç”Ÿé”™è¯? ${error.message}` 
      };
    }
  });

  // è®¾ç½®å¼€æœºå¯åŠ?  ipcMain.handle('set-auto-launch', (event, enabled) => {
    setAutoLaunch(enabled);
    return true;
  });
});

app.on('window-all-closed', () => {
  stopConnectionsWebSocket(); // åœæ­¢è¿æ¥ç®¡ç†
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('before-quit', () => {
  isQuitting = true;
  if (mihomoProcess) {
    mihomoProcess.kill();
  }
  
  // å…³é—­é™æ€æ–‡ä»¶æœåŠ¡å™¨
  if (global.staticServer && global.staticServer.listening) {
    console.log('å…³é—­é™æ€æ–‡ä»¶æœåŠ¡å™¨');
    global.staticServer.close();
  }
  
  // ç¡®ä¿é€€å‡ºæ—¶å…³é—­ç³»ç»Ÿä»£ç†
  try {
    execSync('reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyEnable /t REG_DWORD /d 0 /f');
  } catch (error) {
    console.error('Failed to disable system proxy on exit:', error);
  }
}); 

async function switchNode(nodeName) {
  try {
    // å…³é—­ç°æœ‰è¿æ¥
    if (connectionsWebSocket) {
      connectionsWebSocket.close();
      connectionsWebSocket = null;
    }

    // æ›´æ–°å½“å‰èŠ‚ç‚¹
    currentNode = nodeName;
    
    // é‡æ–°å»ºç«‹è¿æ¥
    await startConnectionsWebSocket();
    
    // æ›´æ–°UI
    if (mainWindow) {
      mainWindow.webContents.send('node-switched', { node: nodeName });
    }
    
    // æ›´æ–°æ‰˜ç›˜æç¤ºå’Œèœå?    if (tray) {
      tray.setToolTip(`FlyClash - ${nodeName}`);
      // æ›´æ–°æ‰˜ç›˜èœå•ä»¥åæ˜ å½“å‰èŠ‚ç‚?      updateTrayMenu();
    }
    
    console.log(`å·²åˆ‡æ¢åˆ°èŠ‚ç‚¹: ${nodeName}`);
  } catch (error) {
    console.error('åˆ‡æ¢èŠ‚ç‚¹å¤±è´¥:', error);
    // é€šçŸ¥å‰ç«¯åˆ‡æ¢å¤±è´¥
    if (mainWindow) {
      mainWindow.webContents.send('node-switch-error', { 
        error: error.message,
        node: nodeName 
      });
    }
  }
}

// è·å–æ€»è¿æ¥ä¿¡æ¯å’Œæ€»æµé‡?async function fetchConnectionsInfo() {
  try {
    const response = await fetch('http://127.0.0.1:9090/connections');
    if (response.ok) {
      const data = await response.json();
      
      // æ›´æ–°è¿æ¥ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ€»æµé‡?      lastConnectionsInfo = {
        ...lastConnectionsInfo,
        downloadTotal: data.downloadTotal || 0,
        uploadTotal: data.uploadTotal || 0,
        connections: data.connections || [],
        activeConnections: data.connections ? data.connections.length : 0
      };
      
      // å‘é€æ›´æ–°åˆ°ä¸»çª—å?      if (mainWindow) {
        mainWindow.webContents.send('connections-update', lastConnectionsInfo);
      }
    }
  } catch (error) {
    console.error('è·å–è¿æ¥ä¿¡æ¯å¤±è´¥:', error);
  }
}

// å…±äº«å‡½æ•°ï¼šä½¿ç”¨HTTPæœåŠ¡å™¨åŠ è½½é¡µé?async function loadPageWithServer(pageName) {
  try {
    // å¦‚æœå·²ç»æœ‰ä¸€ä¸ªæœåŠ¡å™¨åœ¨è¿è¡Œï¼Œå…³é—­å®?    if (global.staticServer && global.staticServer.listening) {
      global.staticServer.close();
    }
    
    // åˆ›å»ºé™æ€æ–‡ä»¶æœåŠ?    const serve = serveStatic(path.join(__dirname, '../out'), { 
      index: ['index.html'], 
      extensions: ['html'],
      fallthrough: false // æ·»åŠ æ­¤é€‰é¡¹ä»¥è¿”å›?04é”™è¯¯
    });
    
    // åˆ›å»ºæœåŠ¡å™?    const server = http.createServer((req, res) => {
      // è®°å½•è¯·æ±‚
      console.log(`[é™æ€æœåŠ¡å™¨] ${req.method} ${req.url}`);
      
      // å¤„ç†é™æ€æ–‡ä»¶è¯·æ±?      serve(req, res, (err) => {
        if (err) {
          console.error('[é™æ€æœåŠ¡å™¨] é”™è¯¯:', err);
          res.statusCode = err.status || 500;
          res.end(err.message);
          return;
        }
        finalhandler(req, res)(err);
      });
    });
    
    // åœ¨éšæœºç«¯å£ä¸Šå¯åŠ¨æœåŠ¡å™?    const port = await new Promise((resolve) => {
      server.listen(0, () => {
        const address = server.address();
        console.log(`é™æ€æ–‡ä»¶æœåŠ¡å™¨è¿è¡Œåœ?http://localhost:${address.port}`);
        resolve(address.port);
      });
    });
    
    // ä¿å­˜æœåŠ¡å™¨å¼•ç”¨ï¼Œä»¥ä¾¿ä»¥åå¯ä»¥å…³é—­å®?    global.staticServer = server;
    
    // ç¡®å®šè¦åŠ è½½çš„URLè·¯å¾„
    let urlPath;
    switch (pageName) {
      case 'nodes':
        urlPath = '/nodes/';
        break;
      case 'settings':
        urlPath = '/settings/';
        break;
      case 'subscriptions':
        urlPath = '/subscriptions/';
        break;
      default:
        urlPath = '/';
        break;
    }
    
    // åŠ è½½URL
    const pageUrl = `http://localhost:${port}${urlPath}`;
    console.log(`åŠ è½½é¡µé¢URL: ${pageUrl}`);
    return mainWindow.loadURL(pageUrl);
  } catch (error) {
    console.error('åŠ è½½é¡µé¢å¤±è´¥:', error);
    throw error;
  }
}

// è®¾ç½®å¼€æœºå¯åŠ?function setAutoLaunch(enabled) {
  try {
    if (process.platform === 'win32') {
      // ä½¿ç”¨Electronçš„å†…ç½®æ–¹æ³•è®¾ç½®å¼€æœºå¯åŠ?      app.setLoginItemSettings({
        openAtLogin: enabled,
        // åœ¨Windowsä¸­ï¼Œpathå‚æ•°æ˜¯å¯é€‰çš„ï¼Œä½†å¦‚æœæŒ‡å®šï¼?        // å®ƒå°†è¦†ç›–Windowsæ³¨å†Œè¡¨é¡¹ä¸­æ³¨å†Œçš„å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾?        path: process.execPath,
        args: []
      });
      
      console.log(`å¼€æœºå¯åŠ¨çŠ¶æ€å·²${enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
      return true;
    } else if (process.platform === 'darwin') {
      // macOSç³»ç»Ÿ
      app.setLoginItemSettings({
        openAtLogin: enabled,
        openAsHidden: false // æ˜¯å¦åœ¨å¯åŠ¨æ—¶éšè—çª—å£
      });
      
      console.log(`macOSå¼€æœºå¯åŠ¨çŠ¶æ€å·²${enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
      return true;
    } else {
      console.warn('å½“å‰å¹³å°ä¸æ”¯æŒè®¾ç½®å¼€æœºå¯åŠ?);
      return false;
    }
  } catch (error) {
    console.error('è®¾ç½®å¼€æœºå¯åŠ¨å¤±è´?', error);
    return false;
  }
}

// è·å–å¼€æœºå¯åŠ¨çŠ¶æ€?function getAutoLaunchState() {
  try {
    // å¯¹äºWindowså’ŒmacOSï¼Œä½¿ç”¨Electron APIè·å–å½“å‰è®¾ç½®
    const settings = app.getLoginItemSettings();
    return settings.openAtLogin;
  } catch (error) {
    console.error('è·å–å¼€æœºå¯åŠ¨çŠ¶æ€å¤±è´?', error);
    return false;
  }
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºå¯¹è±¡
function isObject(item) {
  return item && typeof item === 'object' && !Array.isArray(item);
}

// æ·±åº¦åˆå¹¶é…ç½®
function deepMergeConfig(target, source) {
  // å¤„ç†éå¯¹è±¡ç±»å‹çš„ç›´æ¥è¦†ç›–
  if (!isObject(target) || !isObject(source)) {
    return source;
  }
  
  const result = { ...target };
  
  for (const key in source) {
    // ç”¨æˆ·é…ç½®çš„è¿™äº›å…³é”®å­—æ®µå¿…é¡»è¦†ç›–åŸå§‹é…ç½?    const mustOverrideFields = ['mixed-port', 'allow-lan', 'ipv6', 'log-level', 'external-controller', 'secret'];
    
    if (mustOverrideFields.includes(key)) {
      // ç›´æ¥è¦†ç›–å…³é”®å­—æ®µ
      result[key] = source[key];
    } else if (isObject(source[key])) {
      // é€’å½’åˆå¹¶å¯¹è±¡
      if (key in result) {
        result[key] = deepMergeConfig(result[key], source[key]);
      } else {
        result[key] = source[key];
      }
    } else if (Array.isArray(source[key])) {
      // å¤„ç†æ•°ç»„
      // å¯¹äºè¿™äº›ç‰¹å®šå­—æ®µï¼Œä¿ç•™åŸæœ‰é…ç½®çš„æ•°ç»„
      const preserveArrayFields = ['proxies', 'proxy-groups', 'rules'];
      if (preserveArrayFields.includes(key) && Array.isArray(result[key])) {
        // ä¿ç•™åŸæœ‰æ•°ç»„å†…å®¹ï¼Œä¸è¦†ç›–
        // è¿™äº›å­—æ®µä¸åº”è¢«ç”¨æˆ·é…ç½®è¦†ç›?      } else {
        // å…¶ä»–æ•°ç»„ç›´æ¥è¦†ç›–
        result[key] = source[key];
      }
    } else {
      // å…¶ä»–ç±»å‹ç›´æ¥è¦†ç›–
      result[key] = source[key];
    }
  }
  
  return result;
}

// ç¡®ä¿å…³é”®é…ç½®å­—æ®µå­˜åœ¨ä¸”æœ‰æ•?function validateMergedConfig(config) {
  const validatedConfig = { ...config };
  
  // ç¡®ä¿ç«¯å£æ˜¯æœ‰æ•ˆçš„
  if (!validatedConfig['mixed-port'] || typeof validatedConfig['mixed-port'] !== 'number' || 
      validatedConfig['mixed-port'] < 1 || validatedConfig['mixed-port'] > 65535) {
    validatedConfig['mixed-port'] = 7890; // ä½¿ç”¨é»˜è®¤ç«¯å£
    console.log('ç«¯å£å·æ— æ•ˆï¼Œä½¿ç”¨é»˜è®¤ç«¯å£7890');
  }
  
  // ç¡®ä¿å¸ƒå°”ç±»å‹çš„å­—æ®µæ˜¯å¸ƒå°”å€?  const booleanFields = ['allow-lan', 'ipv6', 'tun'];
  for (const field of booleanFields) {
    if (field in validatedConfig && typeof validatedConfig[field] !== 'boolean') {
      validatedConfig[field] = Boolean(validatedConfig[field]);
      console.log(`å°†å­—æ®?${field} è½¬æ¢ä¸ºå¸ƒå°”å€? ${validatedConfig[field]}`);
    }
  }
  
  // ç¡®ä¿å¿…è¦çš„æ•°ç»„å­—æ®µå­˜åœ?  const requiredArrayFields = ['proxies', 'proxy-groups'];
  for (const field of requiredArrayFields) {
    if (!validatedConfig[field] || !Array.isArray(validatedConfig[field])) {
      if (field === 'proxies' && (!validatedConfig.proxies || !Array.isArray(validatedConfig.proxies))) {
        throw new Error(`æ— æ•ˆçš„é…ç½®ï¼šç¼ºå°‘ ${field} æ•°ç»„`);
      }
      // å¦‚æœå­—æ®µå®Œå…¨ä¸å­˜åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªç©ºæ•°ç»„ä½œä¸ºé»˜è®¤å€?      if (!validatedConfig[field]) {
        validatedConfig[field] = [];
        console.log(`åˆ›å»ºç©ºçš„ ${field} æ•°ç»„ä½œä¸ºé»˜è®¤å€¼`);
      }
    }
  }
  
  return validatedConfig;
}

// é…ç½®çƒ­é‡è½½åŠŸèƒ?function reloadMihomoConfig(configPath) {
  try {
    // ç¡®ä¿é…ç½®æ–‡ä»¶è·¯å¾„å­˜åœ¨
    if (!configPath || !fs.existsSync(configPath)) {
      console.error('é…ç½®æ–‡ä»¶è·¯å¾„æ— æ•ˆï¼Œæ— æ³•é‡æ–°åŠ è½½é…ç½?);
      return false;
    }

    // ç¡®ä¿mihomoè¿›ç¨‹æ­£åœ¨è¿è¡Œ
    if (!mihomoProcess || !mihomoProcess.pid) {
      console.error('Mihomoè¿›ç¨‹ä¸åœ¨è¿è¡ŒçŠ¶æ€ï¼Œæ— æ³•é‡æ–°åŠ è½½é…ç½®');
      return false;
    }

    // ç¡®ä¿ç«¯å£åœ¨ç›‘å¬ä¸­
    const port = 9090; // Mihomo API ç«¯å£
    try {
      // å…ˆæµ‹è¯•ä¸APIçš„è¿æ?      const testReq = http.request({
        hostname: '127.0.0.1',
        port: port,
        path: '/version',
        method: 'GET',
        timeout: 1000 // 1ç§’è¶…æ—?      }, (res) => {
        if (res.statusCode !== 200) {
          console.warn(`ç‰ˆæœ¬APIè¿”å›é?00çŠ¶æ€ç : ${res.statusCode}`);
        }
        // è¿æ¥æˆåŠŸï¼Œç»§ç»­é‡è½½é…ç½?        sendReloadRequest(configPath, port);
      });
      
      testReq.on('error', (err) => {
        console.error('æµ‹è¯•Mihomo APIè¿æ¥å¤±è´¥:', err);
        return false;
      });
      
      testReq.on('timeout', () => {
        testReq.destroy();
        console.error('æµ‹è¯•Mihomo APIè¿æ¥è¶…æ—¶');
        return false;
      });
      
      testReq.end();
      return true; // è¿”å›trueè¡¨ç¤ºè¯·æ±‚å·²å‘é€?    } catch (error) {
      console.error('å°è¯•è¿æ¥Mihomo APIæ—¶å‡ºé”?', error);
      return false;
    }
  } catch (error) {
    console.error('é…ç½®çƒ­é‡è½½å¤±è´?', error);
    return false;
  }
}

// å‘é€é‡è½½é…ç½®è¯·æ±?function sendReloadRequest(configPath, port) {
  try {
    const http = require('http');
    const configData = JSON.stringify({ path: configPath });
    
    const req = http.request({
      hostname: '127.0.0.1',
      port: port,
      path: '/configs',
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(configData)
      },
      timeout: 5000 // 5ç§’è¶…æ—?    });
    
    req.on('error', (err) => {
      console.error('é…ç½®é‡è½½è¯·æ±‚å¤±è´¥:', err);
    });
    
    req.on('timeout', () => {
      req.destroy();
      console.error('é…ç½®é‡è½½è¯·æ±‚è¶…æ—¶');
    });
    
    req.on('response', (res) => {
      let data = '';
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        if (res.statusCode === 200 || res.statusCode === 204) {
          console.log('é…ç½®é‡è½½æˆåŠŸ:', data);
        } else {
          console.error(`é…ç½®é‡è½½å¤±è´¥ï¼ŒçŠ¶æ€ç : ${res.statusCode}ï¼Œå“åº? ${data}`);
        }
      });
    });
    
    req.write(configData);
    req.end();
    
    console.log('å·²è¯·æ±‚Mihomoé‡æ–°åŠ è½½é…ç½®:', configPath);
  } catch (error) {
    console.error('å‘é€é…ç½®é‡è½½è¯·æ±‚å¤±è´?', error);
  }
}

// é‡æ–°ç”Ÿæˆåˆå¹¶é…ç½®å¹¶çƒ­é‡è½½
function regenerateAndReloadConfig() {
  try {
    if (!configFilePath || !fs.existsSync(configFilePath)) {
      console.error('åŸå§‹é…ç½®æ–‡ä»¶ä¸å¯ç”¨ï¼Œæ— æ³•é‡æ–°ç”Ÿæˆé…ç½®');
      return false;
    }

    // è¯»å–åŸå§‹é…ç½®ä¸ç”¨æˆ·è®¾ç½?    const configContent = fs.readFileSync(configFilePath, 'utf8');
    let config;
    try {
      config = yaml.load(configContent);
      if (!config || typeof config !== 'object') {
        throw new Error('åŸå§‹é…ç½®æ ¼å¼æ— æ•ˆ');
      }
    } catch (parseError) {
      console.error('è§£æåŸå§‹é…ç½®æ–‡ä»¶å¤±è´¥:', parseError);
      return false;
    }
    const userSettings = getUserSettings();

    // åˆ›å»ºå·¥ä½œç›®å½•
    const mihomoDir = path.join(userDataPath, 'mihomo');
    if (!fs.existsSync(mihomoDir)) {
      try {
        fs.mkdirSync(mihomoDir, { recursive: true });
      } catch (dirError) {
        console.error('åˆ›å»ºå·¥ä½œç›®å½•å¤±è´¥:', dirError);
        return false;
      }
    }

    // ç”Ÿæˆæ–°çš„åˆå¹¶é…ç½®
    const configFilename = path.basename(configFilePath);
    const overrideConfigFilename = 'override-' + configFilename;
    const overrideConfigPath = path.join(mihomoDir, overrideConfigFilename);

    try {
      // ä½¿ç”¨æ·±åº¦åˆå¹¶ç”Ÿæˆé…ç½®
      const mergedConfig = deepMergeConfig(config, userSettings);
      const validatedConfig = validateMergedConfig(mergedConfig);
      const mergedConfigContent = yaml.dump(validatedConfig);
      
      try {
        fs.writeFileSync(overrideConfigPath, mergedConfigContent, 'utf8');
        console.log(`å·²é‡æ–°ç”Ÿæˆé…ç½®æ–‡ä»? ${overrideConfigPath}`);
      } catch (writeError) {
        console.error('ä¿å­˜ç”Ÿæˆçš„é…ç½®æ–‡ä»¶å¤±è´?', writeError);
        return false;
      }
      
      // æ£€æŸ¥Mihomoæ˜¯å¦åœ¨è¿è¡?      if (!mihomoProcess || !mihomoProcess.pid) {
        console.warn('Mihomoè¿›ç¨‹ä¸åœ¨è¿è¡ŒçŠ¶æ€ï¼Œæ— æ³•çƒ­é‡è½?);
        return false;
      }
      
      // çƒ­é‡è½½é…ç½?      return reloadMihomoConfig(overrideConfigPath);
    } catch (error) {
      console.error('åˆå¹¶é…ç½®å¤±è´¥:', error);
      return false;
    }
  } catch (error) {
    console.error('é‡æ–°ç”Ÿæˆé…ç½®å¤±è´¥:', error);
    return false;
  }
}
